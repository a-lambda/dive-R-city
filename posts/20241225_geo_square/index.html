<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alcor">
<meta name="description" content="Section en travaux">

<title>Get geographic squares – dive-R-city</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-f4a494aaaa964839121371198f4491e6.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Pas de résultats",
    "search-matching-documents-text": "documents trouvés",
    "search-copy-link-title": "Copier le lien vers la recherche",
    "search-hide-matches-text": "Cacher les correspondances additionnelles",
    "search-more-match-text": "correspondance de plus dans ce document",
    "search-more-matches-text": "correspondances de plus dans ce document",
    "search-clear-button-title": "Effacer",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Annuler",
    "search-submit-button-title": "Envoyer",
    "search-label": "Recherche"
  }
}</script>
<link href="../../site_libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet">

<script src="../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js"></script>

<script src="../../site_libs/jquery-3.7.1/jquery.min.js"></script>

<script src="../../site_libs/d3-3.5.6/d3.min.js"></script>

<link href="../../site_libs/profvis-0.3.6.9000/profvis.css" rel="stylesheet">

<script src="../../site_libs/profvis-0.3.6.9000/profvis.js"></script>

<script src="../../site_libs/profvis-0.3.6.9000/scroll.js"></script>

<link href="../../site_libs/highlight-11.10.0/textmate.css" rel="stylesheet">

<script src="../../site_libs/highlight-11.10.0/highlight.min.js"></script>

<script src="../../site_libs/profvis-binding-0.4.0/profvis.js"></script>


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">A lambda</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Recherche"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Basculer la navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <div id="quarto-announcement" data-announcement-id="23982c6eb03bcd697cb57fcefc7fac23" class="alert alert-primary hidden"><i class="bi bi-cone-striped quarto-announcement-icon"></i><div class="quarto-announcement-content">
<p>“Vous lisez une version non finalisée d’un blog actuellement en cours d’élaboration”</p>
</div></div>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Get geographic squares</h1>
                  <div>
        <div class="description">
          <p>Section en travaux</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">news</div>
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Auteur·rice</div>
      <div class="quarto-title-meta-contents">
               <p>Alcor </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Date de publication</div>
      <div class="quarto-title-meta-contents">
        <p class="date">mercredi, 25 décembre 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sur cette page</h2>
   
  <ul>
  <li><a href="#get-geographic-squares" id="toc-get-geographic-squares" class="nav-link active" data-scroll-target="#get-geographic-squares"><span class="header-section-number">1</span> Get geographic squares</a>
  <ul class="collapse">
  <li><a href="#function-get_geo_square-get-a-geographic-square-which-sides-have-alpha-degrees-angle" id="toc-function-get_geo_square-get-a-geographic-square-which-sides-have-alpha-degrees-angle" class="nav-link" data-scroll-target="#function-get_geo_square-get-a-geographic-square-which-sides-have-alpha-degrees-angle"><span class="header-section-number">1.1</span> function <code>get_geo_square</code> get a <code>geographic square</code> which sides have <span class="math inline">\(\alpha\)</span> degrees angle</a></li>
  <li><a href="#function-get_all_geo_squares_on_sphere-cuts-the-sphere-into-geographic-squares-which-sides-have-alpha-degrees-angle" id="toc-function-get_all_geo_squares_on_sphere-cuts-the-sphere-into-geographic-squares-which-sides-have-alpha-degrees-angle" class="nav-link" data-scroll-target="#function-get_all_geo_squares_on_sphere-cuts-the-sphere-into-geographic-squares-which-sides-have-alpha-degrees-angle"><span class="header-section-number">1.2</span> function <code>get_all_geo_squares_on_sphere</code> cuts the sphere into <code>geographic squares</code> which sides have <span class="math inline">\(\alpha\)</span> degrees angle</a></li>
  <li><a href="#function-get_all_geo_squares_on_sphere" id="toc-function-get_all_geo_squares_on_sphere" class="nav-link" data-scroll-target="#function-get_all_geo_squares_on_sphere"><span class="header-section-number">1.3</span> function <code>get_all_geo_squares_on_sphere</code></a></li>
  <li><a href="#benchmarking" id="toc-benchmarking" class="nav-link" data-scroll-target="#benchmarking"><span class="header-section-number">1.4</span> benchmarking</a></li>
  <li><a href="#results-when-applying" id="toc-results-when-applying" class="nav-link" data-scroll-target="#results-when-applying"><span class="header-section-number">1.5</span> results when applying</a></li>
  <li><a href="#function-get_s2_square" id="toc-function-get_s2_square" class="nav-link" data-scroll-target="#function-get_s2_square"><span class="header-section-number">1.6</span> function <code>get_s2_square</code></a></li>
  <li><a href="#benchmarking-1" id="toc-benchmarking-1" class="nav-link" data-scroll-target="#benchmarking-1"><span class="header-section-number">1.7</span> benchmarking</a></li>
  <li><a href="#profiling-function-get_all_s2_squares_on_sphere" id="toc-profiling-function-get_all_s2_squares_on_sphere" class="nav-link" data-scroll-target="#profiling-function-get_all_s2_squares_on_sphere"><span class="header-section-number">1.8</span> profiling function <code>get_all_s2_squares_on_sphere</code></a></li>
  <li><a href="#results-when-applying-1" id="toc-results-when-applying-1" class="nav-link" data-scroll-target="#results-when-applying-1"><span class="header-section-number">1.9</span> results when applying</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="get-geographic-squares" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="get-geographic-squares"><span class="header-section-number">1</span> Get geographic squares</h2>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(s2)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(profvis)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="function-get_geo_square-get-a-geographic-square-which-sides-have-alpha-degrees-angle" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="function-get_geo_square-get-a-geographic-square-which-sides-have-alpha-degrees-angle"><span class="header-section-number">1.1</span> function <code>get_geo_square</code> get a <code>geographic square</code> which sides have <span class="math inline">\(\alpha\)</span> degrees angle</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fonction génératrice de "carré géographique" de `alpha` degrés de côté</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># le point de base (lon, lat) est le point inférieur gauche. </span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>get_geo_square <span class="ot">&lt;-</span> <span class="cf">function</span>(lon, lat, alpha) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  points <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">matrix</span>(</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">c</span>(lon, lat,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        lon <span class="sc">+</span> alpha, lat,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        lon <span class="sc">+</span> alpha, lat <span class="sc">+</span> alpha,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        lon, lat <span class="sc">+</span> alpha,</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        lon, lat),</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">ncol =</span> <span class="dv">2</span>,</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>      <span class="at">byrow =</span> <span class="cn">TRUE</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_polygon</span>(points)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="function-get_all_geo_squares_on_sphere-cuts-the-sphere-into-geographic-squares-which-sides-have-alpha-degrees-angle" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="function-get_all_geo_squares_on_sphere-cuts-the-sphere-into-geographic-squares-which-sides-have-alpha-degrees-angle"><span class="header-section-number">1.2</span> function <code>get_all_geo_squares_on_sphere</code> cuts the sphere into <code>geographic squares</code> which sides have <span class="math inline">\(\alpha\)</span> degrees angle</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>La fonction renvoie un résultat si l’angle <span class="math inline">\(\alpha\)</span> vérifie la condition :</p>
<p><span class="math display">\[90^\circ\space\bmod\space\alpha = 0\]</span></p>
</div>
</div>
</div>
</section>
<section id="function-get_all_geo_squares_on_sphere" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="function-get_all_geo_squares_on_sphere"><span class="header-section-number">1.3</span> function <code>get_all_geo_squares_on_sphere</code></h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>get_all_geo_squares_on_sphere <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="dv">90</span> <span class="sc">%%</span> alpha <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    lon <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">180</span>, <span class="dv">180</span> <span class="sc">-</span> alpha, <span class="at">by =</span> alpha)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    lat <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">90</span>, <span class="dv">90</span> <span class="sc">-</span> alpha, <span class="at">by =</span> alpha)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    geom <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="st">"list"</span>, <span class="at">length =</span> <span class="fu">length</span>(lon) <span class="sc">*</span> <span class="fu">length</span>(lat))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x <span class="cf">in</span> lon) {</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (y <span class="cf">in</span> lat) {</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        geom[[n]] <span class="ot">&lt;-</span> <span class="fu">get_geo_square</span>(x, y, alpha)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    } </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    geom <span class="ot">&lt;-</span> geom <span class="sc">|&gt;</span> <span class="fu">st_as_sfc</span>(<span class="at">crs =</span> <span class="fu">st_crs</span>(<span class="dv">4326</span>))</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(geom)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="benchmarking" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="benchmarking"><span class="header-section-number">1.4</span> benchmarking</h3>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">get_all_geo_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">1</span>),</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">get_all_geo_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">10</span>),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">times =</span> <span class="dv">10</span>L</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  ggplot2<span class="sc">::</span><span class="fu">autoplot</span>()</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/benchmarks-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="results-when-applying" class="level3" data-number="1.5">
<h3 data-number="1.5" class="anchored" data-anchor-id="results-when-applying"><span class="header-section-number">1.5</span> results when applying</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>geo_squares <span class="ot">&lt;-</span> <span class="fu">get_all_geo_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">10</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>geo_centroids <span class="ot">&lt;-</span> geo_squares <span class="sc">|&gt;</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_centroid</span>()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> geo_squares) <span class="sc">+</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> geo_centroids, <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="fl">0.5</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/list_files_results_geo_squares-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------------------------------------</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>geo_squares_moll <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  geo_squares,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">crs =</span> <span class="st">"+proj=moll"</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>geo_centroids_moll <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  geo_centroids,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">crs =</span> <span class="st">"+proj=moll"</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> geo_squares_moll) <span class="sc">+</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> geo_centroids_moll, <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="fl">0.5</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/list_files_results_geo_squares-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="function-get_s2_square" class="level3" data-number="1.6">
<h3 data-number="1.6" class="anchored" data-anchor-id="function-get_s2_square"><span class="header-section-number">1.6</span> function <code>get_s2_square</code></h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>get_s2_square <span class="ot">&lt;-</span> <span class="cf">function</span>(lon, lat, alpha) {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  points <span class="ot">&lt;-</span> <span class="fu">matrix</span>(</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">c</span>(lon, lat,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        lon <span class="sc">+</span> alpha, lat,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        lon <span class="sc">+</span> alpha, lat <span class="sc">+</span> alpha,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        lon, lat <span class="sc">+</span> alpha,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        lon, lat),</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">ncol =</span> <span class="dv">2</span>,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>      <span class="at">byrow =</span> <span class="cn">TRUE</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">s2_make_polygon</span>(points[, <span class="dv">1</span>], points[, <span class="dv">2</span>])</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>function <code>get_all_s2_squares_on_sphere</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>get_all_s2_squares_on_sphere <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="dv">90</span> <span class="sc">%%</span> alpha <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    lon <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">180</span>, <span class="dv">180</span> <span class="sc">-</span> alpha, <span class="at">by =</span> alpha)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    lat <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">90</span>, <span class="dv">90</span> <span class="sc">-</span> alpha, <span class="at">by =</span> alpha)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    geom <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"list"</span>, <span class="at">length =</span> <span class="fu">length</span>(lon) <span class="sc">*</span> <span class="fu">length</span>(lat))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x <span class="cf">in</span> lon) {</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (y <span class="cf">in</span> lat) {</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        geom[[n]] <span class="ot">&lt;-</span> <span class="fu">get_s2_square</span>(x, y, alpha)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    } </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    geom <span class="ot">&lt;-</span> geom <span class="sc">|&gt;</span> </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">map</span>(st_as_sfc) <span class="sc">|&gt;</span> </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">unlist</span>(<span class="at">recursive =</span> <span class="cn">FALSE</span>) <span class="sc">|&gt;</span> </span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">st_as_sfc</span>(<span class="at">crs =</span> <span class="fu">st_crs</span>(<span class="dv">4326</span>))</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(geom)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="benchmarking-1" class="level3" data-number="1.7">
<h3 data-number="1.7" class="anchored" data-anchor-id="benchmarking-1"><span class="header-section-number">1.7</span> benchmarking</h3>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">get_all_s2_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">30</span>),</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">get_all_s2_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">10</span>),</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">times =</span> <span class="dv">100</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  ggplot2<span class="sc">::</span><span class="fu">autoplot</span>()</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/benchmarks_get_all_s2_squares_on_sphere-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="profiling-function-get_all_s2_squares_on_sphere" class="level3" data-number="1.8">
<h3 data-number="1.8" class="anchored" data-anchor-id="profiling-function-get_all_s2_squares_on_sphere"><span class="header-section-number">1.8</span> profiling function <code>get_all_s2_squares_on_sphere</code></h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>profvis<span class="sc">::</span><span class="fu">profvis</span>({</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">get_all_s2_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">10</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="profvis html-widget html-fill-item" id="htmlwidget-ac48a2a640be9e9de9a8" style="width:100%;height:600px;"></div>
<script type="application/json" data-for="htmlwidget-ac48a2a640be9e9de9a8">{"x":{"message":{"prof":{"time":[1,1,2,2,2,2,2,2,3,3,4,4,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,14,14,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,33,33,33,33,33,33,33,33,33,33,33,33,34,34,34,34,34,35,35,35,35,35,35,36,36,36,36,36,36,36,36,37,37,37,37,37,37,37,37,37,37,37,37,37],"depth":[2,1,6,5,4,3,2,1,2,1,7,6,5,4,3,2,1,6,5,4,3,2,1,7,6,5,4,3,2,1,7,6,5,4,3,2,1,4,3,2,1,11,10,9,8,7,6,5,4,3,2,1,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,11,10,9,8,7,6,5,4,3,2,1,2,1,2,1,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1,9,8,7,6,5,4,3,2,1,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,2,1,8,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,3,2,1,10,9,8,7,6,5,4,3,2,1,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,3,2,1,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,2,1,12,11,10,9,8,7,6,5,4,3,2,1,5,4,3,2,1,6,5,4,3,2,1,8,7,6,5,4,3,2,1,13,12,11,10,9,8,7,6,5,4,3,2,1],"label":["lazyLoadDBfetch",".main","union","new_wk_handler","wk::wk_polygon_filter","s2_make_polygon","get_s2_square","get_all_s2_squares_on_sphere","...elt",".main","unique.default","union","new_wk_handler","wk::wk_polygon_filter","s2_make_polygon","get_s2_square","get_all_s2_squares_on_sphere","vapply","recycle_common","wk::xy","s2_make_polygon","get_s2_square","get_all_s2_squares_on_sphere","unique","union","new_wk_handler","wk::wk_polygon_filter","s2_make_polygon","get_s2_square","get_all_s2_squares_on_sphere","<GC>","structure","new_wk_xy","wk::xy","s2_make_polygon","get_s2_square","get_all_s2_squares_on_sphere","s2_geography_writer","s2_make_polygon","get_s2_square","get_all_s2_squares_on_sphere","bb_wrap","bbox.MtrxSetSet","compute_bbox","st_sfc","st_as_sfc.WKB","st_as_sfc.list","st_as_sfc.blob","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","attr.all.equal","all.equal.list","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere",".Call(`_sf_CPL_crs_from_input`, input)","CPL_crs_from_input","make_crs","st_crs.numeric","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","attr.all.equal","all.equal.character","all.equal.list","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","%in%","fix_crs","st_crs.sfc","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","anyNA",".main","attr",".main","data.class","all.equal.character","all.equal.list","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","tryCatch",".set_ops_need_as_vector","union","new_wk_handler","wk::wkb_writer","s2::s2_as_binary","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","as.list","vapply","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","\tidentical(x, NA_crs_)","is.na.crs","st_as_sfc.WKB","st_as_sfc.list","st_as_sfc.blob","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","mode","data.class","all.equal.character","attr.all.equal","all.equal.list","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","any",".main",".Call(`_sf_CPL_crs_from_input`, input)","CPL_crs_from_input","make_crs","st_crs.numeric","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere",".Call(`_sf_CPL_crs_from_input`, input)","CPL_crs_from_input","make_crs","st_crs.numeric","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere",".Call(`_sf_CPL_crs_from_input`, input)","CPL_crs_from_input","make_crs","st_crs.numeric","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","as.list","vapply","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","structure","bb_wrap","bbox.MtrxSetSet","compute_bbox","st_sfc","st_as_sfc.WKB","st_as_sfc.list","st_as_sfc.blob","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","`st_crs<-` = function(x, value) UseMethod(\"st_crs<-\")","st_crs<-","st_sfc","st_as_sfc.WKB","st_as_sfc.list","st_as_sfc.blob","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","attr.all.equal","all.equal.character","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","st_crs = function(x, ...) UseMethod(\"st_crs\")","st_crs","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","vapply","order","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","c",".main","structure","bb_wrap","bbox.MtrxSetSet","compute_bbox","st_sfc","st_as_sfc.WKB","st_as_sfc.list","st_as_sfc.blob","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","st_as_sfc = function(x, ...) UseMethod(\"st_as_sfc\")",".f","map_","map","get_all_s2_squares_on_sphere","structure","s2::s2_as_binary","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","vapply","st_as_sfc.WKB","st_as_sfc.list","st_as_sfc.blob","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere","attr.all.equal","all.equal.list","all.equal.default","Ops.crs","Ops.crs","st_crs<-.sfc","st_sfc","st_cast_sfc_default","st_cast.sfc","st_as_sfc.s2_geography","map_","map","get_all_s2_squares_on_sphere"],"filenum":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,2,3,2,2,4,4,null,null,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,7,5,5,5,4,null,null,null,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,5,5,5,5,6,6,6,4,null,null,null,null,null,2,null,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,null,null,null,null,null,8,4,null,null,null,null,6,6,6,4,null,null,null,5,null,2,2,4,4,null,null,null,null,null,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,2,null,7,5,5,5,4,null,null,null,7,5,5,5,4,null,null,null,7,5,5,5,4,null,null,null,null,6,6,6,4,null,null,null,1,1,1,2,3,2,2,4,4,null,null,null,5,2,3,2,2,4,4,null,null,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,5,8,4,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null,null,null,1,1,1,2,3,2,2,4,4,null,null,null,4,null,null,null,null,null,8,4,null,null,null,3,2,2,4,4,null,null,null,null,null,null,5,5,5,6,6,6,4,null,null,null],"linenum":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,32,137,105,57,587,604,84,84,null,null,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,29,198,64,55,84,null,null,null,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,88,104,55,156,130,178,12,84,null,null,null,null,null,70,null,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,null,null,null,null,null,30,84,null,null,null,null,113,178,12,84,null,null,null,389,null,587,604,84,84,null,null,null,null,null,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,136,null,29,198,64,55,84,null,null,null,29,198,64,55,84,null,null,null,29,198,64,55,84,null,null,null,null,113,178,12,84,null,null,null,9,32,137,105,57,587,604,84,84,null,null,null,156,129,57,587,604,84,84,null,null,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,55,30,84,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null,null,null,9,32,137,105,57,587,604,84,84,null,null,null,84,null,null,null,null,null,30,84,null,null,null,40,587,604,84,84,null,null,null,null,null,null,20,218,156,130,178,12,84,null,null,null],"memalloc":[20.65637969970703,20.65637969970703,24.29358673095703,24.29358673095703,24.29358673095703,24.29358673095703,24.29358673095703,24.29358673095703,27.83197784423828,27.83197784423828,31.50155639648438,31.50155639648438,31.50155639648438,31.50155639648438,31.50155639648438,31.50155639648438,31.50155639648438,35.25213623046875,35.25213623046875,35.25213623046875,35.25213623046875,35.25213623046875,35.25213623046875,38.79476165771484,38.79476165771484,38.79476165771484,38.79476165771484,38.79476165771484,38.79476165771484,38.79476165771484,41.94869232177734,41.94869232177734,41.94869232177734,41.94869232177734,41.94869232177734,41.94869232177734,41.94869232177734,23.67466735839844,23.67466735839844,23.67466735839844,23.67466735839844,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.13618469238281,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.34323883056641,27.55986785888672,27.55986785888672,27.55986785888672,27.55986785888672,27.55986785888672,27.55986785888672,27.55986785888672,27.55986785888672,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.77695465087891,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,27.98723602294922,28.19758605957031,28.19758605957031,21.00339508056641,21.00339508056641,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.21131896972656,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.42584991455078,21.64186859130859,21.64186859130859,21.64186859130859,21.64186859130859,21.64186859130859,21.64186859130859,21.64186859130859,21.64186859130859,21.86079406738281,21.86079406738281,21.86079406738281,21.86079406738281,21.86079406738281,21.86079406738281,21.86079406738281,21.86079406738281,21.86079406738281,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.07753753662109,22.29130554199219,22.29130554199219,20.98177337646484,20.98177337646484,20.98177337646484,20.98177337646484,20.98177337646484,20.98177337646484,20.98177337646484,20.98177337646484,21.19399261474609,21.19399261474609,21.19399261474609,21.19399261474609,21.19399261474609,21.19399261474609,21.19399261474609,21.19399261474609,21.39736938476562,21.39736938476562,21.39736938476562,21.39736938476562,21.39736938476562,21.39736938476562,21.39736938476562,21.39736938476562,21.60294342041016,21.60294342041016,21.60294342041016,21.60294342041016,21.60294342041016,21.60294342041016,21.60294342041016,21.60294342041016,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,21.81403350830078,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.02669525146484,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.24079895019531,22.44948577880859,22.44948577880859,22.44948577880859,22.44948577880859,22.44948577880859,22.44948577880859,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.13627624511719,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.33802032470703,21.54580688476562,21.54580688476562,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.75958251953125,21.97734069824219,21.97734069824219,21.97734069824219,21.97734069824219,21.97734069824219,22.19110107421875,22.19110107421875,22.19110107421875,22.19110107421875,22.19110107421875,22.19110107421875,22.40357971191406,22.40357971191406,22.40357971191406,22.40357971191406,22.40357971191406,22.40357971191406,22.40357971191406,22.40357971191406,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484,21.11702728271484],"meminc":[0,0,3.63720703125,0,0,0,0,0,3.53839111328125,0,3.669578552246094,0,0,0,0,0,0,3.750579833984375,0,0,0,0,0,3.542625427246094,0,0,0,0,0,0,3.1539306640625,0,0,0,0,0,0,-18.27402496337891,0,0,0,3.461517333984375,0,0,0,0,0,0,0,0,0,0,0.2070541381835938,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.2166290283203125,0,0,0,0,0,0,0,0.2170867919921875,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.2102813720703125,0,0,0,0,0,0,0,0,0,0,0.2103500366210938,0,-7.194190979003906,0,0.2079238891601562,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.2145309448242188,0,0,0,0,0,0,0,0,0,0.2160186767578125,0,0,0,0,0,0,0,0.2189254760742188,0,0,0,0,0,0,0,0,0.2167434692382812,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.2137680053710938,0,-1.309532165527344,0,0,0,0,0,0,0,0.21221923828125,0,0,0,0,0,0,0,0.2033767700195312,0,0,0,0,0,0,0,0.2055740356445312,0,0,0,0,0,0,0,0.211090087890625,0,0,0,0,0,0,0,0,0,0,0,0.2126617431640625,0,0,0,0,0,0,0,0,0,0.2141036987304688,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.2086868286132812,0,0,0,0,0,-1.313209533691406,0,0,0,0,0,0,0,0,0,0,0,0.2017440795898438,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.2077865600585938,0,0.213775634765625,0,0,0,0,0,0,0,0,0,0,0,0.2177581787109375,0,0,0,0,0.2137603759765625,0,0,0,0,0,0.2124786376953125,0,0,0,0,0,0,0,-1.286552429199219,0,0,0,0,0,0,0,0,0,0,0,0],"filename":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"sf/R/bbox.R","sf/R/bbox.R","sf/R/sfc.R","sf/R/wkb.R","sf/R/sfc.R","sf/R/sfc.R","sf/R/sp.R","sf/R/sp.R",null,null,null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,"sf/R/RcppExports.R","sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/sp.R",null,null,null,null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,null,null,"sf/R/sfc.R",null,null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,null,null,null,null,null,"sf/R/s2.R","sf/R/sp.R",null,null,null,null,"sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,"sf/R/crs.R",null,"sf/R/sfc.R","sf/R/sfc.R","sf/R/sp.R","sf/R/sp.R",null,null,null,null,null,null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,"sf/R/sfc.R",null,"sf/R/RcppExports.R","sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/sp.R",null,null,null,"sf/R/RcppExports.R","sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/sp.R",null,null,null,"sf/R/RcppExports.R","sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/sp.R",null,null,null,null,"sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,"sf/R/bbox.R","sf/R/bbox.R","sf/R/bbox.R","sf/R/sfc.R","sf/R/wkb.R","sf/R/sfc.R","sf/R/sfc.R","sf/R/sp.R","sf/R/sp.R",null,null,null,"sf/R/crs.R","sf/R/sfc.R","sf/R/wkb.R","sf/R/sfc.R","sf/R/sfc.R","sf/R/sp.R","sf/R/sp.R",null,null,null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,"sf/R/crs.R","sf/R/s2.R","sf/R/sp.R",null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null,null,null,"sf/R/bbox.R","sf/R/bbox.R","sf/R/bbox.R","sf/R/sfc.R","sf/R/wkb.R","sf/R/sfc.R","sf/R/sfc.R","sf/R/sp.R","sf/R/sp.R",null,null,null,"sf/R/sp.R",null,null,null,null,null,"sf/R/s2.R","sf/R/sp.R",null,null,null,"sf/R/wkb.R","sf/R/sfc.R","sf/R/sfc.R","sf/R/sp.R","sf/R/sp.R",null,null,null,null,null,null,"sf/R/crs.R","sf/R/crs.R","sf/R/crs.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/cast_sfc.R","sf/R/sp.R",null,null,null]},"interval":10,"files":[{"filename":"sf/R/bbox.R","content":"\n#' @name st_bbox\n#' @param x object of class \\code{bbox}\n#' @export\nis.na.bbox = function(x) identical(x, NA_bbox_)\n\nbb_wrap = function(bb) {\n\tstopifnot(is.numeric(bb), length(bb) == 4)\n\tstructure(as.double(bb), names = c(\"xmin\", \"ymin\", \"xmax\", \"ymax\"), class = \"bbox\")\n}\n\nbbox.Set = function(obj, ...) {\n\tsel = !sfc_is_empty(obj)\n\tif (! any(sel))\n\t\tNA_bbox_\n\telse\n\t\tbb_wrap(CPL_get_bbox(unclass(obj)[sel], 0))\n}\nbbox.Mtrx = function(obj, ...) {\n\tif (length(obj) == 0)\n\t\tNA_bbox_\n\telse\n\t\tbb_wrap(CPL_get_bbox(list(obj), 1)) # note the list()\n}\nbbox.MtrxSet = function(obj, ...) {\n\tif (length(obj) == 0)\n\t\tNA_bbox_\n\telse\n\t\tbb_wrap(CPL_get_bbox(obj, 1))\n}\nbbox.MtrxSetSet = function(obj, ...) {\n\tif (length(obj) == 0)\n\t\tNA_bbox_\n\telse\n\t\tbb_wrap(CPL_get_bbox(obj, 2))\n}\nbbox.MtrxSetSetSet = function(obj, ...) {\n\tif (length(obj) == 0)\n\t\tNA_bbox_\n\telse\n\t\tbb_wrap(CPL_get_bbox(obj, 3))\n}\n\n#' Return bounding of a simple feature or simple feature set\n#'\n#' Return bounding of a simple feature or simple feature set\n#' @param obj object to compute the bounding box from\n#' @param ... for format.bbox, passed on to \\link[base]{format} to format individual numbers\n#' @export\n#' @return a numeric vector of length four, with \\code{xmin}, \\code{ymin}, \\code{xmax}\n#' and \\code{ymax} values; if \\code{obj} is of class \\code{sf}, \\code{sfc}, \\code{Spatial} or \\code{Raster}, the object\n#' returned has a class \\code{bbox}, an attribute \\code{crs} and a method to print the\n#' bbox and an \\code{st_crs} method to retrieve the coordinate reference system\n#' corresponding to \\code{obj} (and hence the bounding box). \\link{st_as_sfc} has a\n#' methods for \\code{bbox} objects to generate a polygon around the four bounding box points.\n#' @name st_bbox\n#' @examples\n#' a = st_sf(a = 1:2, geom = st_sfc(st_point(0:1), st_point(1:2)), crs = 4326)\n#' st_bbox(a)\n#' st_as_sfc(st_bbox(a))\nst_bbox = function(obj, ...) UseMethod(\"st_bbox\")\n\n#' @export\n#' @name st_bbox\nst_bbox.POINT = function(obj, ...) bb_wrap(c(obj[1L], obj[2L], obj[1L], obj[2L]))\n#' @export\n#' @name st_bbox\nst_bbox.MULTIPOINT = bbox.Mtrx\n#' @export\n#' @name st_bbox\nst_bbox.LINESTRING = bbox.Mtrx\n#' @export\n#' @name st_bbox\nst_bbox.POLYGON = function(obj, ...) if (st_is_full(obj)) FULL_bbox_ else bbox.MtrxSet(obj)\n#' @export\n#' @name st_bbox\nst_bbox.MULTILINESTRING = bbox.MtrxSet\n#' @export\n#' @name st_bbox\nst_bbox.MULTIPOLYGON = bbox.MtrxSetSet\n\nbbox_list = function(obj, ...) {\n\ts = vapply(obj, st_bbox, c(0.,0.,0.,0.)) # dispatch on class\n\tif (length(s) == 0 || all(is.na(s[1L,])))\n\t\tNA_bbox_\n\telse\n\t\tbb_wrap(c(min(s[1L,], na.rm = TRUE), min(s[2L,], na.rm = TRUE),\n\t\t  max(s[3L,], na.rm = TRUE), max(s[4L,], na.rm = TRUE)))\n}\n\n#' @name st_bbox\n#' @export\nst_bbox.GEOMETRYCOLLECTION = bbox_list\n\n#' @name st_bbox\n#' @export\nst_bbox.MULTISURFACE = bbox_list\n\n#' @name st_bbox\n#' @export\nst_bbox.MULTICURVE = bbox_list\n\n#' @name st_bbox\n#' @export\nst_bbox.CURVEPOLYGON = bbox_list\n\n#' @name st_bbox\n#' @export\nst_bbox.COMPOUNDCURVE = bbox_list\n\n#' @name st_bbox\n#' @export\nst_bbox.POLYHEDRALSURFACE = bbox.MtrxSetSet\n\n#' @name st_bbox\n#' @export\nst_bbox.TIN = bbox.MtrxSetSet\n\n#' @name st_bbox\n#' @export\nst_bbox.TRIANGLE = bbox.MtrxSet\n\n#' @name st_bbox\n#' @export\nst_bbox.CIRCULARSTRING = function(obj, ...) {\n\t# this is of course wrong:\n\tst_bbox(st_cast(obj, \"LINESTRING\"))\n}\n\n#' @export\nprint.bbox = function(x, ...) {\n\tx = structure(x, crs = NULL, class = NULL)\n\tprint(set_units(x, attr(x, \"units\"), mode = \"standard\"), ...)\n}\n\ncompute_bbox = function(obj) {\n\tswitch(class(obj)[1],\n\t\tsfc_POINT = bb_wrap(bbox.Set(obj)),\n\t\tsfc_MULTIPOINT = bb_wrap(bbox.MtrxSet(obj)),\n\t\tsfc_LINESTRING = bb_wrap(bbox.MtrxSet(obj)),\n\t\tsfc_POLYGON = if (any(st_is_full(obj))) FULL_bbox_ else bb_wrap(bbox.MtrxSetSet(obj)),\n\t\tsfc_MULTILINESTRING = bb_wrap(bbox.MtrxSetSet(obj)),\n\t\tsfc_MULTIPOLYGON = bb_wrap(bbox.MtrxSetSetSet(obj)),\n\t\tbbox_list(obj)\n\t)\n}\n\n#' @name st_bbox\n#' @export\nst_bbox.sfc = function(obj, ...) structure(attr(obj, \"bbox\"), crs = st_crs(obj))\n\n#' @name st_bbox\n#' @export\nst_bbox.sf = function(obj, ...) st_bbox(st_geometry(obj))\n\n#' @name st_bbox\n#' @export\nst_bbox.Spatial = function(obj, ...) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tbb = sp::bbox(obj)\n\tstructure(bb_wrap(c(bb[1,1],bb[2,1],bb[1,2],bb[2,2])),\n\t\tcrs = st_crs(slot(obj, \"proj4string\")))\n}\n\n#' @name st_bbox\n#' @export\nst_bbox.Raster = function(obj, ...) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tif (!requireNamespace(\"raster\", quietly = TRUE))\n\t\tstop(\"package raster required, please install it first\")\n\tbb = sp::bbox(obj)\n\tstructure(bb_wrap(c(bb[1,1],bb[2,1],bb[1,2],bb[2,2])),\n\t\tcrs = st_crs(sp::proj4string(obj)))\n}\n\n#' @name st_bbox\n#' @export\nst_bbox.Extent = function(obj, ..., crs = NA_crs_) {\n\tif (!requireNamespace(\"raster\", quietly = TRUE))\n\t\tstop(\"package raster required, please install it first\")\n\tstructure(bb_wrap(c(obj@xmin, obj@ymin, obj@xmax, obj@ymax)), crs = st_crs(crs))\n}\n\n#' @name st_bbox\n#' @param crs object of class \\code{crs}, or argument to \\link{st_crs}, specifying the CRS of this bounding box.\n#' @examples\n#' st_bbox(c(xmin = 16.1, xmax = 16.6, ymax = 48.6, ymin = 47.9), crs = st_crs(4326))\n#' @export\nst_bbox.numeric = function(obj, ..., crs = NA_crs_) {\n\tstructure(bb_wrap(obj[c(\"xmin\", \"ymin\", \"xmax\", \"ymax\")]), crs = st_crs(crs))\n}\n\n#' @export\nst_bbox.bbox = function(obj, ...) obj\n\n\n#' @export\n\"$.bbox\" = function(x, name) {\n\tswitch(name,\n\t\txrange =,\n\t\txlim = x[c(\"xmin\", \"xmax\")],\n\t\tyrange =,\n\t\tylim = x[c(\"ymin\", \"ymax\")],\n\t\txmin = x[\"xmin\"],\n\t\tymin = x[\"ymin\"],\n\t\txmax = x[\"xmax\"],\n\t\tymax = x[\"ymax\"],\n\t\tstop(\"unsupported name\")\n\t)\n}\n\n#' @name st_bbox\n#' @details \\code{NA_bbox_} represents the missing value for a \\code{bbox} object\n#' @export\nNA_bbox_ = structure(rep(NA_real_, 4),\n\tnames = c(\"xmin\", \"ymin\", \"xmax\", \"ymax\"),\n\tcrs = NA_crs_,\n\tclass = \"bbox\")\n\n#' @name st_bbox\n#' @details \\code{NA_bbox_} represents the missing value for a \\code{bbox} object\n#' @export\nFULL_bbox_ = structure(c(-180.,-90.,180.,90.),\n\tnames = c(\"xmin\", \"ymin\", \"xmax\", \"ymax\"),\n\tcrs = NA_crs_,\n\tclass = \"bbox\")\n\n#' @name st_bbox\n#' @export\nformat.bbox = function(x, ...) {\n\tp1 = paste0(\"(\",paste0(c(format(x[1], ...), format(x[2], ...)), collapse=\",\"),\")\")\n\tp2 = paste0(\"(\",paste0(c(format(x[3], ...), format(x[4], ...)), collapse=\",\"),\")\")\n\tpaste0(\"(\",p1,\",\",p2,\")\")\n}","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/bbox.R"},{"filename":"sf/R/sfc.R","content":"#' @export\nstr.sfc <- function(object, ...) {\n\tn <- length(object)\n\tcat(paste0(class(object)[1], \" of length \", n))\n\tif (n > 0) {\n\t\tcat(\"; first list element: \")\n\t\tstr(object[[1]], ...)\n\t}\n}\n\n#' @export\nformat.sfc = function(x, ..., width = 30) {\n\tvapply(x, format, \"\", ..., width = width)\n}\n\n#' Create simple feature geometry list column\n#'\n#' Create simple feature geometry list column, set class, and add coordinate reference system and precision.\n#' For data.frame alternatives see [st_sf()]. To convert a foreign object to `sfc`, see [st_as_sfc()]\n#'\n#' @name sfc\n#' @aliases sfc_POINT sfc_LINESTRING sfc_POLYGON sfc_MULTIPOINT sfc_MULTILINESTRING sfc_MULTIPOLYGON sfc_GEOMETRYCOLLECTION\n#' @param ... zero or more simple feature geometries (objects of class \\code{sfg}), or a single list of such objects; \\code{NULL} values will get replaced by empty geometries.\n#' @param crs coordinate reference system: integer with the EPSG code, or character with proj4string\n#' @param precision numeric; see \\link{st_as_binary}\n#' @param check_ring_dir see \\link{st_read}\n#' @param dim character; if this function is called without valid geometries, this argument may carry the right dimension to set empty geometries\n#' @param recompute_bbox logical; use \\code{TRUE} to force recomputation of the bounding box\n#' @param oriented logical; if \\code{TRUE}, the ring is oriented such that left of the edges is inside the polygon; this is\n#' needed for convering polygons larger than half the globe to s2\n#' @return an object of class \\code{sfc}, which is a classed list-column with simple feature geometries.\n#'\n#' @details A simple feature geometry list-column is a list of class\n#' \\code{c(\"stc_TYPE\", \"sfc\")} which most often contains objects of identical type;\n#' in case of a mix of types or an empty set, \\code{TYPE} is set to the\n#' superclass \\code{GEOMETRY}.\n#' @examples\n#' pt1 = st_point(c(0,1))\n#' pt2 = st_point(c(1,1))\n#' (sfc = st_sfc(pt1, pt2))\n#' sfc[sfc[1], op = st_is_within_distance, dist = 0.5]\n#' d = st_sf(data.frame(a=1:2, geom=sfc))\n#' @export\nst_sfc = function(..., crs = NA_crs_, precision = 0.0, check_ring_dir = FALSE, dim,\n\t\t\t\t  recompute_bbox = FALSE, oriented = NA) {\n\tlst = list(...)\n\t# if we have only one arg, which is already a list with sfg's, but NOT a geometrycollection:\n\t# (this is the old form of calling st_sfc; it is way faster to call st_sfc(lst) if lst\n\t# already contains a zillion sfg objects, than do.call(st_sfc, lst) ...\n\tif (length(lst) && inherits(lst[[1]], \"sf\"))\n\t\tstop(\"use st_as_sfc() to extract geometries from an sf object\")\n\tif (length(lst) == 1 && is.list(lst[[1]]) && !inherits(lst[[1]], \"sfg\")\n\t\t\t&& (length(lst[[1]]) == 0 || inherits(lst[[1]][[1]], \"sfg\") || is.null(lst[[1]][[1]])))\n\t\tlst = lst[[1]]\n\tstopifnot(is.numeric(crs) || is.character(crs) || inherits(crs, \"crs\"))\n\n\t# check for NULLs:\n\ta = attributes(lst)\n\tis_null = sfc_is_null(lst)\n\tlst = unclass(lst)\n\tlst = lst[! is_null]\n\tattributes(lst) = a\n\n\tdims_and_types = sfc_unique_sfg_dims_and_types(lst)\n\t\n\tcls = if (length(lst) == 0) # empty set: no geometries read\n\t\t\tc(\"sfc_GEOMETRY\", \"sfc\")\n\t\telse {\n\t\t\t# class: do we have a mix of geometry types?\n\t\t\tsingle = if (!is.null(attr(lst, \"single_type\"))) # set by CPL_read_wkb:\n\t\t\t\t\tattr(lst, \"single_type\")\n\t\t\t\telse\n\t\t\t\t\tlength(dims_and_types[[2]]) == 1L\n\t\t\tattr(lst, \"single_type\") = NULL # clean up\n\t\t\tif (single)\n\t\t\t\tc(paste0(\"sfc_\", dims_and_types[[2]][1]), \"sfc\")\n\t\t\telse\n\t\t\t\tc(\"sfc_GEOMETRY\", \"sfc\")    # the mix\n\t\t}\n\n\tif (any(is_null)) {\n\t\tif (missing(dim)) {\n\t\t\tdim = if (length(lst) == 0) # we have no clue:\n\t\t\t\t\t\"XY\"\n\t\t\t\telse\n\t\t\t\t\tdims_and_types[[1]][1]\n\t\t}\n\t\tret = vector(\"list\", length(is_null))\n\t\tret[!is_null] = lst\n\t\tret[ is_null] = list(typed_empty(cls, nchar(dim), dim = dim))\n\t\tattributes(ret) = attributes(lst)\n\t\tlst = ret\n\t\tdims_and_types = sfc_unique_sfg_dims_and_types(lst)\n\t}\n\n\t# set class:\n\tclass(lst) = cls\n\n\t# set precision\n\tif (! missing(precision) || is.null(attr(lst, \"precision\")))\n\t\tattr(lst, \"precision\") = precision\n\n\t# compute bbox, if not set:\n\tbb = attr(lst, \"bbox\")\n\tif (is.null(bb) || anyNA(bb) || recompute_bbox)\n\t\tattr(lst, \"bbox\") = compute_bbox(lst)\n\n\t# compute z_range, if dims permit and not set\n\tzr = attr(lst, \"z_range\")\n\tif (is.null(zr) || anyNA(zr)) {\n\t\tu <- dims_and_types[[1]]\n\t\tif( \"XYZM\" %in% u ) {\n\t\t\tattr(lst, \"z_range\") = compute_z_range(lst)\n\t\t\tattr(lst, \"m_range\") = compute_m_range(lst)\n\t\t} else if ( \"XYZ\" %in% u ) {\n\t\t\tattr(lst, \"z_range\") = compute_z_range(lst)\n\t\t} else if (\"XYM\" %in% u ) {\n\t\t\tattr(lst, \"m_range\") = compute_m_range(lst)\n\t\t}\n\t}\n\n\t# check ring directions:\n\tif (check_ring_dir) # also GEOMETRYCOLLECTION?\n\t\tlst = check_ring_dir(lst)\n\n\t# get & set crs:\n\tif (is.na(crs) && !is.null(attr(lst, \"crs\")))\n\t\tcrs = attr(lst, \"crs\")\n\tst_crs(lst) = crs\n\n\t# set classes attr in case of GEOMETRY\n\tif (inherits(lst, \"sfc_GEOMETRY\")) # recompute, as NULL's may have been substituted:\n\t\tattr(lst, \"classes\") = vapply(lst, class, rep(NA_character_, 3))[2L,]\n\n\t# set n_empty, check XY* is uniform:\n\tif (is.null(attr(lst, \"n_empty\")) || any(is_null)) { # n_empty is set by CPL_read_wkb:\n\t\tattr(lst, \"n_empty\") = sum(sfc_is_empty(lst))\n# \t\thttps://github.com/r-spatial/sf/issues/1592 :\n#\t\tif (length(u <- unique(sfg_classes[1L,])) > 1)\n#\t\t\tstop(paste(\"found multiple dimensions:\", paste(u, collapse = \" \")))\n\t}\n\tif (isTRUE(oriented))\n\t\tattr(lst, \"oriented\") = TRUE\n\n\tlst\n}\n\n#' @name sfc\n#' @param x object of class \\code{sfc}\n#' @param i record selection. Might also be an \\code{sfc}/\\code{sf} object to work with the \\code{op} argument\n#' @param j ignored if `op` is specified\n#' @param op function, geometrical binary predicate function to apply when\n#'   \\code{i} is a \\code{sf}/\\code{sfc} object. Additional arguments can be\n#'   specified using \\code{...}, see examples.\n#' @details if `x` has a `dim` attribute (i.e. is an `array` or `matrix`) then `op` cannot be used.\n#' @export\n\"[.sfc\" = function(x, i, j, ..., op = st_intersects) {\n\tprecision = st_precision(x)\n\tcrs = st_crs(x)\n\tdim = if (length(x)) class(x[[1]])[1] else \"XY\"\n\tif (!missing(i) && (inherits(i, c(\"sf\", \"sfc\", \"sfg\"))))\n\t\ti = lengths(op(x, i, ...)) != 0\n\tif (!is.null(dim(x))) # x is an array with geometries\n\t\tst_sfc(NextMethod(), crs = crs, precision = precision, dim = dim)\n\telse # x is a list but avoid NextMethod() to allow j, ... to be specified & ignored:\n\t\tst_sfc(unclass(x)[i], crs = crs, precision = precision, dim = dim)\n}\n\n#' @export\n\"[<-.sfc\" = function (x, i, j, ..., value) {\n\tif (is.null(value) || inherits(value, \"sfg\"))\n\t\tvalue = list(value)\n\tret = st_sfc(NextMethod(), recompute_bbox = TRUE)\n\tstructure(ret, n_empty = sum(sfc_is_empty(ret)))\n}\n\n#' @export\nc.sfc = function(..., recursive = FALSE) {\n\tlst = list(...)\n\tchk_equal_crs(lst)\n\tclasses = sapply(lst, function(x) class(x)[1])\n\tle = lengths(lst)\n\tif (any(le > 0))\n\t\tclasses = classes[le > 0] # removes the empty set GEOMETRY objects\n\tucls = unique(classes)\n\tcls = if (length(ucls) > 1) # a mix:\n\t\t\tc(\"sfc_GEOMETRY\", \"sfc\")\n\t\telse\n\t\t\tc(ucls, \"sfc\")\n\n\tret = unlist(lapply(lst, unclass), recursive = FALSE)\n\tattributes(ret) = attributes(lst[[1]]) # crs\n\tclass(ret) = cls\n\tattr(ret, \"bbox\") = compute_bbox(ret) # dispatch on class\n\tattr(ret, \"n_empty\") = sum(sapply(lst, attr, which = \"n_empty\"))\n\tif (inherits(ret, \"sfc_GEOMETRY\"))\n\t\tattr(ret, \"classes\") = vapply(ret, class, rep(\"\", 3))[2L,]\n\tret\n}\n\n#' @export\nprint.sfc = function(x, ..., n = 5L, what = \"Geometry set for\", append = \"\") {\n\tsep = if (length(x) != 1) \"s\" else \"\"\n\tcls = substr(class(x)[1], 5, nchar(class(x)[1]))\n\tcat(paste0(what, \" \", length(x), \" feature\", sep, \" \", append))\n\tif (! is.null(attr(x, \"n_empty\"))) {\n\t\tne = attr(x, \"n_empty\")\n\t\tif (ne > 0)\n\t\t\tcat(paste0(\" (with \", ne, ifelse(ne > 1, \" geometries \", \" geometry \"), \"empty)\"))\n\t}\n\tif (!is.null(dim(x)))\n\t\tcat(paste0(\" [dim: \", paste(dim(x), collapse = \" x \"), \"]\"))\n\tcat(\"\\n\")\n\tif (length(x)) {\n\t\tcat(paste0(\"Geometry type: \", cls, \"\\n\"))\n\t\tu = sort(unique(sapply(x, function(x) class(x)[1])))\n\t\tcat(paste0(\"Dimension:     \", paste(u, collapse = \", \"), \"\\n\"))\n\t}\n\tcat(    paste0(\"Bounding box:  \"))\n\tbb = signif(attr(x, \"bbox\"), options(\"digits\")$digits)\n\tcat(paste(paste(names(bb), bb[], sep = \": \"), collapse = \" \"))\n\tcat(\"\\n\")\n\tif( !is.null( attr(x, \"z_range\"))) {\n\t\tcat(paste0(\"z_range:       \"))\n\t\tzb = signif(attr(x, \"z_range\"), options(\"digits\")$digits)\n\t\tcat(paste(paste(names(zb), zb[], sep = \": \"), collapse = \" \"))\n\t\tcat(\"\\n\")\n\t}\n\tif( !is.null( attr(x, \"m_range\"))) {\n\t\tcat(paste0(\"m_range:       \"))\n\t\tmb = signif(attr(x, \"m_range\"), options(\"digits\")$digits)\n\t\tcat(paste(paste(names(mb), mb[], sep = \": \"), collapse = \" \"))\n\t\tcat(\"\\n\")\n\t}\n\t# attributes: epsg, proj4string, precision\n\tcrs = st_crs(x)\n\tif (is.na(crs))\n\t\tcat(paste0(\"CRS:           NA\\n\"))\n\telse {\n\t\tp = crs_parameters(crs)\n\t\tif (p$Name == \"unknown\") {\n\t\t\tif (is.character(crs$input) && !is.na(crs$input) && crs$input != \"unknown\")\n\t\t\t\tp$Name = crs$input\n\t\t\telse\n\t\t\t\tp$Name = crs$proj4string\n\t\t}\n\t\tif (p$IsGeographic)\n\t\t\tcat(paste0(\"Geodetic CRS:  \", p$Name, \"\\n\"))\n\t\telse\n\t\t\tcat(paste0(\"Projected CRS: \", p$Name, \"\\n\"))\n\t}\n\tif (attr(x, \"precision\") != 0.0) {\n\t\tcat(    paste0(\"Precision:     \"))\n\t\tif (attr(x, \"precision\") < 0.0)\n\t\t\tcat(\"float (single precision)\\n\")\n\t\telse\n\t\t\tcat(paste(attr(x, \"precision\"), \"\\n\"))\n\t} # else cat(\"double (default; no precision model)\\n\")\n\tif (length(x) > n && n > 0)\n\t\tcat(paste0(\"First \", n, \" geometries:\\n\"))\n\tfor (i in seq_len(min(n, length(x))))\n\t\tif (inherits(x[[i]], \"sfg\"))\n\t\t\tprint(x[[i]], width = 50, crs = crs)\n\t\telse\n\t\t\tprint(x[[i]], crs = crs)\n\tinvisible(x)\n}\n\n#' Summarize simple feature column\n#'\n#' Summarize simple feature column\n#' @param object object of class \\code{sfc}\n#' @param ... ignored\n#' @param maxsum maximum number of classes to summarize the simple feature column to\n#' @param maxp4s maximum number of characters to print from the PROJ string\n#' @method summary sfc\n#' @export\nsummary.sfc = function(object, ..., maxsum = 7L, maxp4s = 10L) {\n\tu = factor(vapply(object, function(x) WKT_name(x, FALSE), \"\"))\n    epsg = paste0(\"epsg:\", st_crs(object)$epsg)\n\tlevels(u) = c(levels(u), epsg)\n    p4s = attr(object, \"crs\")$proj4string\n\tif (!is.na(p4s)) {\n\t\tif (nchar(p4s) > maxp4s)\n\t\t\tp4s = paste0(substr(p4s, 1L, maxp4s), \"...\")\n\t\tlevels(u) = c(levels(u), p4s)\n\t}\n    summary(u, maxsum = maxsum, ...)\n}\n\n#' @export\nas.data.frame.sfc = function(x, ...) {\n\tret = data.frame(row.names = seq_along(x))\n\tret$geometry = x\n\tret\n}\n\n\n#' @name st_geometry\n#' @export\nst_geometry.sfc = function(obj, ...) obj\n\n#' Return geometry type of an object\n#'\n#' Return geometry type of an object, as a factor\n#' @param x object of class \\link{sf} or \\link{sfc}\n#' @param by_geometry logical; if \\code{TRUE}, return geometry type of each geometry,\n#' else return geometry type of the set\n#' @return a factor with the geometry type of each simple feature geometry\n#' in \\code{x}, or that of the whole set\n#' @export\nst_geometry_type = function(x, by_geometry = TRUE) {\n\tx = st_geometry(x)\n\tf = if (by_geometry)\n\t\t\tvapply(x, function(y) class(y)[2], \"\")\n\t\telse\n\t\t\tsubstring(class(x)[1], 5)\n\tfactor(f, levels =\n\t\tc(\"GEOMETRY\",\n\t\t\"POINT\",\n\t\t\"LINESTRING\",\n\t\t\"POLYGON\",\n\t\t\"MULTIPOINT\",\n\t\t\"MULTILINESTRING\",\n\t\t\"MULTIPOLYGON\",\n\t\t\"GEOMETRYCOLLECTION\",\n\t\t\"CIRCULARSTRING\",\n\t\t\"COMPOUNDCURVE\",\n\t\t\"CURVEPOLYGON\",\n\t\t\"MULTICURVE\",\n\t\t\"MULTISURFACE\",\n\t\t\"CURVE\",\n\t\t\"SURFACE\",\n\t\t\"POLYHEDRALSURFACE\",\n\t\t\"TIN\",\n\t\t\"TRIANGLE\"))\n}\n\n#' Drop or add Z and/or M dimensions from feature geometries\n#'\n#' Drop Z and/or M dimensions from feature geometries, resetting classes appropriately\n#' @param x object of class \\code{sfg}, \\code{sfc} or \\code{sf}\n#' @param ... ignored\n#' @param drop logical; drop, or (`FALSE`) add?\n#' @param what character which dimensions to drop or add\n#' @details Only combinations \\code{drop=TRUE}, \\code{what = \"ZM\"}, and \\code{drop=FALSE}, \\code{what=\"Z\"} are supported so far.\n#' In the latter case, \\code{x} should have \\code{XY} geometry, and zero values are added for the \\code{Z} dimension.\n#' @examples\n#' st_zm(st_linestring(matrix(1:32,8)))\n#' x = st_sfc(st_linestring(matrix(1:32,8)), st_linestring(matrix(1:8,2)))\n#' st_zm(x)\n#' a = st_sf(a = 1:2, geom=x)\n#' st_zm(a)\n#' @export\nst_zm <- function(x, ..., drop = TRUE, what = \"ZM\") UseMethod(\"st_zm\")\n\n#' @export\nst_zm.sf <- function(x, ..., drop = TRUE, what = \"ZM\") {\n\tst_geometry(x) = st_zm(st_geometry(x), drop = drop, what = what)\n\tx\n}\n\n#' @export\nst_zm.sfc <- function(x, ..., drop = TRUE, what = \"ZM\") {\n\tst_sfc(lapply(x, st_zm, drop = drop, what = what), crs = st_crs(x))\n}\n\n#' @export\nst_zm.sfg <- function(x, ..., drop = TRUE, what = \"ZM\") {\n\tif (drop && what == \"ZM\") {\n\t\tret = if (is.list(x))\n\t\t\tlapply(x, st_zm, drop = drop, what = what)\n\t\telse if (is.matrix(x))\n\t\t\tx[, 1:2, drop = FALSE]\n\t\telse\n\t\t\tx[1:2]\n\t\tstructure(ret, class = c(\"XY\", class(x)[2:3]))\n\t} else if (!drop && what == \"Z\") {\n\t\tif (class(x)[1] != \"XY\")\n\t\t\tstop(\"adding Z only supported for XY geometries\")\n\t\tret = if (is.list(x))\n\t\t\tlapply(x, st_zm, drop = drop, what = what)\n\t\telse if (is.matrix(x))\n\t\t\tcbind(unclass(x), 0)\n\t\telse\n\t\t\tc(unclass(x), 0)\n\t\tstructure(ret, class = c(\"XYZ\", class(x)[2:3]))\n\t} else\n\t\tstop(\"this combination of `x', `drop' and `what' is not implemented\")\n}\n\n#' @export\nst_zm.list <- function(x, ..., drop = TRUE, what = \"ZM\")\n\tlapply(x, st_zm, drop = drop, what = what)\n\n#' @export\nst_zm.matrix <- function(x, ..., drop = TRUE, what = \"ZM\")  {\n\tif (drop && what == \"ZM\") {\n\t\tx[,1:2]\n\t} else if (!drop && what == \"Z\") {\n\t\tcbind(unclass(x), 0)\n\t} else\n\t\tstop(\"this combination of drop and what is not implemented\")\n}\n\n#' Get precision\n#'\n#' @param x object of class \\code{sfc} or \\code{sf}\n#' @export\nst_precision <- function(x) {\n  UseMethod(\"st_precision\")\n}\n\n#' @export\nst_precision.sf <- function(x) {\n  x <- st_geometry(x)\n  st_precision(x)\n}\n\n#' @export\nst_precision.sfc <- function(x) {\n  attr(x, \"precision\")\n}\n\n#' Set precision\n#'\n#' @rdname st_precision\n#' @param precision numeric, or object of class \\code{units} with distance units (but see details); see \\link{st_as_binary} for how to do this.\n#' @details If \\code{precision} is a \\code{units} object, the object on which we set precision must have a coordinate reference system with compatible distance units.\n#'\n#' Setting a \\code{precision} has no direct effect on coordinates of geometries, but merely set an attribute tag to an \\code{sfc} object.\n#' The effect takes place in \\link{st_as_binary} or, more precise, in the C++ function \\code{CPL_write_wkb}, where simple feature geometries are being serialized to well-known-binary (WKB).\n#' This happens always when routines are called in GEOS library (geometrical operations or predicates), for writing geometries using \\link{st_write} or \\link{write_sf}, \\code{st_make_valid} in package \\code{lwgeom}; also \\link{aggregate} and \\link{summarise} by default union geometries, which calls a GEOS library function.\n#' Routines in these libraries receive rounded coordinates, and possibly return results based on them. \\link{st_as_binary} contains an example of a roundtrip of \\code{sfc} geometries through WKB, in order to see the rounding happening to R data.\n#'\n#' The reason to support precision is that geometrical operations in GEOS or liblwgeom may work better at reduced precision. For writing data from R to external resources it is harder to think of a good reason to limiting precision.\n#'\n#' @seealso \\link{st_as_binary} for an explanation of what setting precision does, and the examples therein.\n#' @examples\n#' x <- st_sfc(st_point(c(pi, pi)))\n#' st_precision(x)\n#' st_precision(x) <- 0.01\n#' st_precision(x)\n#' @export\nst_set_precision <- function(x, precision) {\n    UseMethod(\"st_set_precision\")\n}\n\n#' @export\nst_set_precision.sfc <- function(x, precision) {\n    if (length(precision) != 1) {\n        stop(\"Precision applies to all dimensions and must be of length 1.\", call. = FALSE)\n    }\n\n\tif (inherits(precision, \"units\")) {\n\t\tu = st_crs(x)$ud_unit\n\t\tif (is.null(u))\n\t\t\tstop(\"cannot use precision expressed as units when target object has no units (CRS) set\")\n\t\tunits(precision) = 1/u # convert\n\t\tprecision = as.numeric(precision)\n\t}\n\n    if (is.na(precision) || !is.numeric(precision)) {\n        stop(\"Precision must be numeric\", call. = FALSE)\n    }\n    structure(x, precision = precision)\n}\n\n#' @export\nst_set_precision.sf <- function(x, precision) {\n    st_geometry(x) <- st_set_precision(st_geometry(x), precision)\n    return(x)\n}\n\n#' @name st_precision\n#' @param value precision value\n#' @export\n\"st_precision<-\" <- function(x, value) {\n    st_set_precision(x, value)\n}\n\ntyped_empty = function(cls, ncol = 2, dim = \"XY\") {\n\tswitch(cls[1],\n\t\tsfc_POINT = st_point(rep(NA_real_, ncol), dim = dim),\n\t\tsfc_MULTIPOINT = st_multipoint(matrix(numeric(0), ncol = ncol), dim = dim),\n\t\tsfc_LINESTRING = st_linestring(matrix(numeric(0), ncol = ncol), dim = dim),\n\t\tsfc_MULTILINESTRING = st_multilinestring(dim = dim),\n\t\tsfc_POLYGON = st_polygon(dim = dim),\n\t\tsfc_MULTIPOLYGON = st_multipolygon(dim = dim),\n\t\tst_geometrycollection(dims = dim))\n}\n\n#' retrieve coordinates in matrix form\n#'\n#' retrieve coordinates in matrix form\n#' @param x object of class sf, sfc or sfg\n#' @param ... ignored\n#' @return matrix with coordinates (X, Y, possibly Z and/or M) in rows, possibly followed by integer indicators \\code{L1},...,\\code{L3} that point out to which structure the coordinate belongs; for \\code{POINT} this is absent (each coordinate is a feature), for \\code{LINESTRING} \\code{L1} refers to the feature, for \\code{MULTILINESTRING} \\code{L1} refers to the part and \\code{L2} to the simple feature, for \\code{POLYGON} \\code{L1} refers to the main ring or holes and \\code{L2} to the simple feature, for \\code{MULTIPOLYGON} \\code{L1} refers to the main ring or holes, \\code{L2} to the ring id in the \\code{MULTIPOLYGON}, and \\code{L3} to the simple feature.\n#' \n#' For \\code{POLYGONS}, \\code{L1} can be used to identify exterior rings and inner holes. \n#' The exterior ring is when \\code{L1} is equal to 1. Interior rings are identified \n#' when \\code{L1} is greater than 1. \\code{L2} can be used to differentiate between the \n#' feature. Whereas for \\code{MULTIPOLYGON}, \\code{L3} refers to the \\code{MULTIPOLYGON}\n#' feature and \\code{L2} refers to the component \\code{POLYGON}.\n#' \n#' @export\nst_coordinates = function(x, ...) UseMethod(\"st_coordinates\")\n\n#' @export\nst_coordinates.sf = function(x, ...) st_coordinates(st_geometry(x))\n\n#' @export\nst_coordinates.sfg = function(x, ...) st_coordinates(st_geometry(x))\n\n#' @export\nst_coordinates.sfc = function(x, ...) {\n\tif (length(x) == 0)\n\t\treturn(matrix(nrow = 0, ncol = 2))\n\n\tret = switch(class(x)[1],\n\t\tsfc_POINT = matrix(unlist(x, use.names = FALSE), nrow = length(x), byrow = TRUE,\n\t\t     dimnames = NULL),\n\t\tsfc_MULTIPOINT = ,\n\t\tsfc_LINESTRING = coord_2(x),\n\t\tsfc_MULTILINESTRING = ,\n\t\tsfc_POLYGON = coord_3(x),\n\t\tsfc_MULTIPOLYGON = coord_4(x),\n\t\tstop(paste(\"not implemented for objects of class\", class(x)[1]))\n\t)\n\tDims = class(x[[1]])[1]\n\tncd = nchar(Dims)\n\tcolnames(ret)[1:ncd] = vapply(seq_len(ncd), function(i) substr(Dims, i, i), \"\")\n\tret\n}\n\ncoord_2 = function(x) { # x is a list with matrices\n\tcbind(do.call(rbind, x), L1 = rep(seq_along(x), times = vapply(x, nrow, 0L)))\n}\n\ncoord_3 = function(x) { # x is a list of lists with matrices\n\tx = lapply(x, coord_2)\n\tcbind(do.call(rbind, x), L2 = rep(seq_along(x), times = vapply(x, nrow, 0L)))\n}\n\ncoord_4 = function(x) { # x is a list of lists of lists with matrices\n\tx = lapply(x, coord_3)\n\tcbind(do.call(rbind, x), L3 = rep(seq_along(x), times = vapply(x, nrow, 0L)))\n}\n\n#' @export\nrep.sfc = function(x, ...) {\n\tst_sfc(NextMethod(), crs = st_crs(x))\n}\n\ncheck_ring_dir = function(x) {\n\tcheck_polygon = function(pol) {\n\t\tsa = sapply(pol, CPL_signed_area)\n\t\trevert = if (length(sa))\n\t\t\t\tc(sa[1] < 0, sa[-1] > 0)\n\t\t\telse\n\t\t\t\tlogical(0)\n\t\tpol[revert] = lapply(pol[revert], function(m) m[nrow(m):1,])\n\t\tpol\n\t}\n\tcls = if (inherits(x, \"sfg\"))\n\t\t\tclass(x)[2]\n\t\telse\n\t\t\tclass(x)[1]\n\tret = switch(cls,\n\t\tPOLYGON = check_polygon(x),\n\t\tMULTIPOLYGON = ,\n\t\tsfc_POLYGON = lapply(x, check_polygon),\n\t\tsfc_MULTIPOLYGON = lapply(x, function(y) structure(lapply(y, check_polygon), class = class(y))),\n\t\tstop(paste(\"check_ring_dir: not supported for class\", class(x)[1]))\n\t)\n\tattributes(ret) = attributes(x)\n\tret\n}\n\n#' @name st_as_sfc\n#' @export\nst_as_sfc.list = function(x, ..., crs = NA_crs_) {\n\n\tif (length(x) == 0)\n\t\treturn(st_sfc(crs = crs))\n\n\tif (is.raw(x[[1]]))\n\t\tst_as_sfc.WKB(structure(x, class = \"WKB\"), ..., crs = crs)\n\telse if (inherits(x[[1]], \"sfg\"))\n\t\tst_sfc(x, crs = crs)\n\telse if (is.character(x[[1]])) { # hex wkb or wkt:\n\t\tch12 = substr(x[[1]], 1, 2)\n\t\tif (ch12 == \"0x\" || ch12 == \"00\" || ch12 == \"01\") # hex wkb\n\t\t\tst_as_sfc.WKB(structure(x, class = \"WKB\"), ..., crs = crs)\n\t\telse\n\t\t\tst_as_sfc(unlist(x), ..., crs = crs) # wkt\n\t} else\n\t\tstop(paste(\"st_as_sfc.list: don't know what to do with list with elements of class\", class(x[[1]])))\n}\n\n#' @name st_as_sfc\n#' @export\nst_as_sfc.blob = function(x, ...) {\n\tst_as_sfc.list(x, ...)\n}\n\n#' @name st_as_sfc\n#' @export\nst_as_sfc.bbox = function(x, ...) {\n\tif (st_is_full(x))\n\t\tst_as_sfc(\"POLYGON FULL\", crs = st_crs(x))\n\telse {\n\t\tbox = st_polygon(list(matrix(x[c(1, 2, 3, 2, 3, 4, 1, 4, 1, 2)], ncol = 2, byrow = TRUE)))\n\t\tst_sfc(box, crs = st_crs(x), oriented = TRUE)\n\t}\n}\n\nPOLYGON_FULL = matrix(c(0,-90,0,-90), 2, byrow = TRUE)\n\n#' predicate whether a geometry is equal to a POLYGON FULL\n#'\n#' predicate whether a geometry is equal to a POLYGON FULL\n#' @param x object of class `sfg`, `sfc` or `sf`\n#' @param ... ignored, except when it contains a `crs` argument to inform unspecified `is_longlat`\n#' @returns logical, indicating whether geometries are POLYGON FULL (a spherical\n#' polygon covering the entire sphere)\n#' @export\nst_is_full = function(x, ...) UseMethod(\"st_is_full\")\n\n#' @export\n#' @name st_is_full\n#' @param is_longlat logical; output of \\link{st_is_longlat} of the parent `sfc` object\nst_is_full.sfg = function(x, ..., is_longlat = NULL) {\n\tif (identical(is_longlat, FALSE)) # we know these are Cartesian coordinates:\n\t\tFALSE\n\telse\n\t\tsf_use_s2() && inherits(x, \"POLYGON\") &&\n\t\tlength(x) == 1 && nrow(x[[1]]) == 2 && identical(x[[1]], POLYGON_FULL)\n}\n\n#' @export\n#' @name st_is_full\nst_is_full.sfc = function(x, ...) {\n\tif (sf_use_s2() && inherits(x, c(\"sfc_POLYGON\", \"sfc_GEOMETRY\")))\n\t\tsfc_is_full(x)\n\telse\n\t\trep_len(FALSE, length(x))\n}\n\n#' @export\n#' @name st_is_full\nst_is_full.sf = function(x, ...) {\n\tst_is_full(st_geometry(x), ...)\n}\n\n#' @export\n#' @name st_is_full\nst_is_full.bbox = function(x, ...) {\n\tisTRUE(sf_use_s2() && st_is_longlat(x) && all(x == c(-180,-90,180,90)))\n}","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/sfc.R"},{"filename":"sf/R/wkb.R","content":"# convert character string, as typically PostgreSQL returned blobs, to raw vector;\n# skips a leading \"0x\", as this is created by PostGIS when using ST_asBinary()\n#\n# most wkb read/write stuff was modified & extended from Ian Cook's wkb package,\n# https://cran.r-project.org/web/packages/wkb/index.html\n#\nhex_to_raw = function(y) {\n\tstopifnot((nchar(y) %% 2) == 0)\n\tif (startsWith(y, \"0x\"))\n\t\ty = substr(y, 3, nchar(y))\n\tas.raw(as.numeric(paste0(\"0x\", vapply(seq_len(nchar(y)/2),\n\t\tfunction(x) substr(y, (x-1)*2+1, x*2), \"\")))) # SLOW, hence the Rcpp implementation\n}\n\nskip0x = function(x) {\n\tif (is.na(x))\n\t\t\"010700000000000000\" # empty GeometryCollection, st_as_binary(st_geometrycollection())\n\telse if (startsWith(x, \"0x\"))\n\t\tsubstr(x, 3, nchar(x))\n\telse\n\t\tx\n}\n\n#' @name st_as_sfc\n#' @param EWKB logical; if `TRUE`, parse as EWKB (extended WKB; PostGIS: ST_AsEWKB), otherwise as ISO WKB (PostGIS: ST_AsBinary)\n#' @param spatialite logical; if \\code{TRUE}, WKB is assumed to be in the spatialite dialect, see \\url{https://www.gaia-gis.it/gaia-sins/BLOB-Geometry.html}; this is only supported in native endian-ness (i.e., files written on system with the same endian-ness as that on which it is being read).\n#' @param pureR logical; if `TRUE`, use only R code, if `FALSE`, use compiled (C++) code; use `TRUE` when the endian-ness of the binary differs from the host machine (\\code{.Platform$endian}).\n#' @details When converting from WKB, the object \\code{x} is either a character vector such as typically obtained from PostGIS (either with leading \"0x\" or without), or a list with raw vectors representing the features in binary (raw) form.\n#' @examples\n#' wkb = structure(list(\"01010000204071000000000000801A064100000000AC5C1441\"), class = \"WKB\")\n#' st_as_sfc(wkb, EWKB = TRUE)\n#' wkb = structure(list(\"0x01010000204071000000000000801A064100000000AC5C1441\"), class = \"WKB\")\n#' st_as_sfc(wkb, EWKB = TRUE)\n#' @export\nst_as_sfc.WKB = function(x, ..., EWKB = FALSE, spatialite = FALSE, pureR = FALSE, crs = NA_crs_) {\n\tif (EWKB && spatialite)\n\t\tstop(\"arguments EWKB and spatialite cannot both be TRUE\")\n\tif (spatialite && pureR)\n\t\tstop(\"pureR implementation for spatialite reading is not available\")\n    if (all(vapply(x, is.character, TRUE))) {\n\t\tx <- if (pureR)\n\t\t\t\tstructure(lapply(x, hex_to_raw), class = \"WKB\")\n\t\t\telse\n\t\t\t\tstructure(CPL_hex_to_raw(vapply(x, skip0x, USE.NAMES = FALSE, \"\")), class = \"WKB\")\n\t} else # direct call with raw:\n\t\tstopifnot(inherits(x, \"WKB\"), vapply(x, is.raw, TRUE)) # WKB as raw\n\tif (any(lengths(x) == 0))\n\t\tstop(\"cannot read WKB object from zero-length raw vector\")\n\tret = if (pureR)\n\t\t\tR_read_wkb(x, readWKB, EWKB = EWKB)\n\t\telse\n\t\t\tCPL_read_wkb(x, EWKB, spatialite)\n\tif (is.na(crs) && (EWKB || spatialite) && !is.null(attr(ret, \"srid\")) && attr(ret, \"srid\") != 0)\n\t\tcrs = attr(ret, \"srid\")\n\tif (! is.na(st_crs(crs))) {\n\t\tattr(ret, \"srid\") = NULL # remove\n\t\tst_sfc(ret, crs = crs)\n\t} else\n\t\tst_sfc(ret) # leave attr srid in place: PostGIS srid that is not an EPSG code\n}\n\n#' @export\n#' @examples\n#' st_as_sfc(st_as_binary(st_sfc(st_point(0:1)))[[1]], crs = 4326)\n#' @name st_as_sfc\nst_as_sfc.raw = function(x, ...) {\n\tst_as_sfc(structure(list(x), class = \"WKB\"), ...)\n}\n\nR_read_wkb = function(x, readWKB, EWKB = EWKB) {\n\tret = lapply(x, readWKB, EWKB = EWKB)\n\tsrid = attr(ret[[1]], \"srid\")\n\tret = lapply(ret, function(x) { attr(x, \"srid\") = NULL; x })\n\tattr(ret, \"srid\") = srid\n\tret\n}\n\nsf.tp = toupper(c(\n\t# \"Geometry\",          # 0\n\t\"Point\",               # 1\n\t\"LineString\",          # 2\n\t\"Polygon\",             # 3\n\t\"MultiPoint\",          # 4\n\t\"MultiLineString\",     # 5\n\t\"MultiPolygon\",        # 6\n\t\"GeometryCollection\",  # 7\n\t\"CircularString\",      # 8 x\n\t\"CompoundCurve\",       # 9 x\n\t\"CurvePolygon\",        # 10 x\n\t\"MultiCurve\",          # 11 x\n\t\"MultiSurface\",        # 12 x\n\t\"Curve\",               # 13 x *\n\t\"Surface\",             # 14 x *\n\t\"PolyhedralSurface\",   # 15\n\t\"TIN\",                 # 16\n\t\"Triangle\"             # 17\n\t)) # \"Geometry\" = 0, should not be matched, is a superclass only\n\t   # x: not described in ISO document\n\t   # *: GDAL support see https://trac.osgeo.org/gdal/ticket/6401\n\nreadWKB = function(x, EWKB = FALSE) {\n\tstopifnot(inherits(x, \"raw\"))\n\trc <- rawConnection(x, \"r\")\n\ton.exit(close(rc))\n\tseek(rc, 0L)\n\t# read data:\n\treadData(rc, EWKB = EWKB)\n}\n\nparseTypeEWKB = function(wkbType, endian) {\n\t# following the OGC doc, 3001 is POINT with ZM; turns out, PostGIS does sth else -\n\t# read WKB, as well as EWKB; this post is more inormative of what is going on:\n\t# https://lists.osgeo.org/pipermail/postgis-devel/2004-December/000710.html\n\t# (without SRID, Z, M and ZM this all doesn't matter)\n\t# comparison ISO WKB and EWKB:\n\t# https://lists.osgeo.org/pipermail/postgis-devel/2004-December/000695.html\n\tstopifnot(length(wkbType) == 4)\n\tif (endian == \"little\") {\n\t\tsf_type = as.numeric(wkbType[1])\n\t\tinfo = as.raw(as.integer(wkbType[4]) %/% 2^4)\n\t} else {\n\t\tsf_type = as.numeric(wkbType[4])\n\t\tinfo = as.raw(as.integer(wkbType[1]) %/% 2^4)\n\t}\n\ttp = sf.tp[sf_type]\n\tstopifnot(!is.na(tp))\n\thas_srid = as.logical(info & as.raw(2)) # 2-bit is \"on\"?\n\tzm = if ((info & as.raw(12)) == as.raw(12))\n\t\t\"XYZM\"\n\telse if (info & as.raw(8))\n\t\t\"XYZ\"\n\telse if (info & as.raw(4))\n\t\t\"XYM\"\n\telse if (info == as.raw(0) || info == as.raw(2))\n\t\t\"XY\"\n\telse\n\t\tstop(paste(\"unknown value for info:\", info))\n\tlist(dims = nchar(zm), zm = zm, tp = tp, has_srid = has_srid)\n}\n\nparseTypeISO = function(wkbType) {\n\ttp = sf.tp[wkbType %% 1000]\n\tstopifnot(!is.na(tp))\n\tdd = wkbType %/% 1000\n\tzm = if (dd == 0)\n\t\t\"XY\"\n\telse if (dd == 1)\n\t\t\"XYZ\"\n\telse if (dd == 2)\n\t\t\"XYM\"\n\telse if (dd == 3)\n\t\t\"XYZM\"\n\telse\n\t\tstop(paste(\"unknown value for wkbType:\", wkbType))\n\tlist(dims = nchar(zm), zm = zm, tp = tp, has_srid = FALSE)\n}\n\nreadData = function(rc, EWKB = FALSE) {\n\t# read byte order:\n\tbyteOrder <- readBin(rc, what = \"raw\", size = 1L)\n\tstopifnot(byteOrder %in% c(as.raw(0L), as.raw(1L)))\n\tendian = ifelse(byteOrder == as.raw(1L), \"little\", \"big\")\n\t# read wkbType:\n\tsrid = NA_integer_\n\tif (EWKB) {\n\t\twkbType <- readBin(rc, what = \"raw\", n = 4L, size = 1L, endian = endian)\n\t\tpt <- parseTypeEWKB(wkbType, endian)\n\t\tif (pt$has_srid)\n\t\t\tsrid <- readBin(rc, what = \"integer\", size = 4L, endian = endian)\n\t} else {\n\t\twkbType <- readBin(rc, what = \"integer\", n = 1L, size = 4L, endian = endian)\n\t\tpt <- parseTypeISO(wkbType)\n\t}\n\t# read data part:\n\tret = switch(pt$tp,\n\t\tPOINT = readPoint(rc, pt$dims, endian),\n\t\tCURVE = ,\n\t\tCIRCULARSTRING = ,\n\t\tLINESTRING = readMatrix(rc, pt$dims, endian),\n\t\tSURFACE = ,\n\t\tPOLYGON = ,\n\t\tTRIANGLE = readMatrixList(rc, pt$dims, endian),\n\t\tMULTIPOINT = readMPoints(rc, pt$dims, endian, EWKB),\n\t\tMULTILINESTRING = ,\n\t\tMULTICURVE = ,\n\t\tMULTIPOLYGON = ,\n\t\tMULTISURFACE = ,\n\t\tPOLYHEDRALSURFACE = ,\n\t\tTIN = lapply(readGC(rc, pt$dims, endian, EWKB), unclass),\n\t\tGEOMETRYCOLLECTION = readGC(rc, pt$dims, endian, EWKB),\n\t\tCURVEPOLYGON = readGC(rc, pt$dims, endian, EWKB),\n\t\tstop(paste(\"type\", pt$tp, \"unsupported\")))\n\tclass(ret) <- c(pt$zm, pt$tp, \"sfg\")\n\tif (!is.na(srid))\n\t\tattr(ret, \"srid\") <- srid\n\tret\n}\n\nreadPoint = function(rc, dims, endian) {\n\treadBin(rc, what = \"double\", n = as.integer(dims), size = 8L, endian = endian)\n}\nreadMPoints = function(rc, dims, endian, EWKB) {\n\tnpts = readBin(rc, what = \"integer\", n = 1L, size = 4L, endian = endian)\n\tdo.call(rbind, lapply(seq_len(npts), function(x) readData(rc, EWKB)))\n}\nreadMatrix = function(rc, dims, endian) {\n\tnpts = readBin(rc, what = \"integer\", n = 1L, size = 4L, endian = endian)\n\tm = readBin(rc, what = \"double\", n = as.integer(npts * dims), size = 8L, endian = endian)\n\tt(matrix(m, nrow = dims)) # x1 y1, x2 y2 etc -> t()\n}\nreadMatrixList = function(rc, dims, endian) {\n\tnmtrx = readBin(rc, what = \"integer\", n = 1L, size = 4L, endian = endian)\n\tlapply(seq_len(nmtrx), function(x) readMatrix(rc, dims, endian))\n}\n#readMatrixListList = function(rc, dims, endian) {\n#\tnmtrxl = readBin(rc, what = \"integer\", n = 1L, size = 4L, endian = endian)\n#\tlapply(seq_len(nmtrxl), function(x) readMatrixList(rc, dims, endian))\n#}\nreadGC = function(rc, dims, endian, EWKB) {\n\tngc = readBin(rc, what = \"integer\", n = 1L, size = 4L, endian = endian)\n\tlapply(seq_len(ngc), function(x) readData(rc, EWKB))\n}\n\n#' Convert sfc object to an WKB object\n#'\n#' Convert sfc object to an WKB object\n#' @param x object to convert\n#' @param ... ignored\n#' @name st_as_binary\n#' @export\nst_as_binary = function(x, ...) UseMethod(\"st_as_binary\")\n\n#' @name st_as_binary\n#' @param endian character; either \"big\" or \"little\"; default: use that of platform\n#' @param EWKB logical; use EWKB (PostGIS), or (default) ISO-WKB?\n#' @param pureR logical; use pure R solution, or C++?\n#' @param precision numeric; if zero, do not modify; to reduce precision: negative values convert to float (4-byte real); positive values convert to round(x*precision)/precision. See details.\n#' @param hex logical; return as (unclassed) hexadecimal encoded character vector?\n#' @param srid integer; override srid (can be used when the srid is unavailable locally).\n#' @details \\code{st_as_binary} is called on sfc objects on their way to the GDAL or GEOS libraries, and hence does rounding (if requested) on the fly before e.g. computing spatial predicates like \\link{st_intersects}. The examples show a round-trip of an \\code{sfc} to and from binary.\n#'\n#' For the precision model used, see also \\url{https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html}. There, it is written that: ``... to specify 3 decimal places of precision, use a scale factor of 1000. To specify -3 decimal places of precision (i.e. rounding to the nearest 1000), use a scale factor of 0.001.''. Note that ALL coordinates, so also Z or M values (if present) are affected.\n#' @export\n#' @examples\n#' # examples of setting precision:\n#' st_point(c(1/3, 1/6)) %>% st_sfc(precision = 1000) %>% st_as_binary %>% st_as_sfc\n#' st_point(c(1/3, 1/6)) %>% st_sfc(precision =  100) %>% st_as_binary %>% st_as_sfc\n#' st_point(1e6 * c(1/3, 1/6)) %>% st_sfc(precision = 0.01) %>% st_as_binary %>% st_as_sfc\n#' st_point(1e6 * c(1/3, 1/6)) %>% st_sfc(precision = 0.001) %>% st_as_binary %>% st_as_sfc\nst_as_binary.sfc = function(x, ..., EWKB = FALSE, endian = .Platform$endian, pureR = FALSE,\n\t\tprecision = attr(x, \"precision\"), hex = FALSE) {\n\tstopifnot(endian %in% c(\"big\", \"little\"))\n\tif (pureR && precision != 0.0)\n\t\tstop(\"for non-zero precision values, use pureR = FALSE\")\n\tret = if (pureR)\n\t\tstructure(lapply(x, st_as_binary.sfg, EWKB = EWKB, pureR = pureR, endian = endian), class = \"WKB\")\n\telse {\n\t\tstopifnot(endian == .Platform$endian)\n\t\tattr(x, \"precision\") = precision\n\t\tstructure(CPL_write_wkb(x, EWKB), class = \"WKB\")\n\t}\n\tif (hex)\n\t\tvapply(ret, CPL_raw_to_hex, \"\")\n\telse\n\t\tret\n}\n\ncreateType = function(x, endian, EWKB = FALSE) {\n\tdims = x[1]  # \"XY\", \"XYZ\", \"XYM\", or \"XYZM\"\n\tcl = x[2]\n\tm = match(cl, sf.tp)\n\tif (is.na(m))\n\t\tstop(paste(\"Class\", cl, \"not matched\"))\n\t# return:\n\tif (! EWKB) # ISO: add 1000s\n\t\tas.integer(m + switch(dims, \"XYZ\" = 1000, \"XYM\" = 2000, \"XYZM\" = 3000, 0))\n\telse { # EWKB: set higher bits\n\t\tret = raw(4)\n\t\tret[1] = as.raw(m) # set up little-endian\n\t\tret[4] = as.raw(switch(dims, \"XYZ\" = 0x80, \"XYM\" = 0x40, \"XYZM\" = 0xC0, 0))\n\t\tif (endian == \"big\")\n\t\t\trev(ret)\n\t\telse\n\t\t\tret\n\t}\n}\n\n#' @name st_as_binary\n#' @export\nst_as_binary.sfg = function(x, ..., endian = .Platform$endian, EWKB = FALSE, pureR = FALSE,\n\t\thex = FALSE, srid = 0) {\n# if pureR, it's done here, if not, it's done in st_as_binary.sfc\n\tstopifnot(endian %in% c(\"big\", \"little\"))\n\tif (! pureR)\n\t\tst_as_binary.sfc(st_sfc(x), endian == endian, EWKB = EWKB, pureR = pureR, hex = hex, srid = srid, ...)[[1]]\n\telse {\n\t\trc <- rawConnection(raw(0), \"r+\")\n\t\ton.exit(close(rc))\n\t\twriteData(x, rc, endian, EWKB)\n\t\tr = rawConnectionValue(rc)\n\t\tif (hex)\n\t\t\tr = rawToHex(r)\n\t\tr\n\t}\n}\n\n#' Convert raw vector(s) into hexadecimal character string(s)\n#'\n#' Convert raw vector(s) into hexadecimal character string(s)\n#' @param x raw vector, or list with raw vectors\n#' @export\nrawToHex = function(x) {\n\tif (is.raw(x))\n\t\tCPL_raw_to_hex(x)\n\telse if (is.list(x) && all(vapply(x, is.raw, TRUE)))\n\t\tvapply(x, function(rw) CPL_raw_to_hex(rw), \"\")\n\telse\n\t\tstop(paste(\"not implemented for objects of class\", class(x)))\n}\n\nwriteData = function(x, rc, endian, EWKB = FALSE) {\n\tif (endian == \"big\")\n\t\twriteBin(as.raw(0L), rc)\n\telse\n\t\twriteBin(as.raw(1L), rc)\n\tif (EWKB)\n\t\twriteBin(createType(class(x), endian, TRUE), rc, size = 1L, endian = endian)\n\telse\n\t\twriteBin(createType(class(x)), rc, size = 4L, endian = endian)\n\t# TODO (?): write SRID in case of EWKB?\n\t# write out x:\n\tswitch(class(x)[2],\n\t\tPOINT = writeBin(as.vector(as.double(x)), rc, size = 8L, endian = endian),\n\t\tLINESTRING = writeMatrix(x, rc, endian),\n\t\tPOLYGON = ,\n\t\tTRIANGLE = writeMatrixList(x, rc, endian),\n\t\tMULTIPOINT = writeMPoints(x, rc, endian, EWKB),\n\t\tPOLYHEDRALSURFACE = ,\n\t\tTIN = ,\n\t\tMULTILINESTRING = ,\n\t\tMULTIPOLYGON = writeMulti(x, rc, endian, EWKB),\n\t\tGEOMETRYCOLLECTION = writeGC(x, rc, endian, EWKB),\n\t\tstop(paste(\"unimplemented class to write:\", class(x)[2]))\n\t)\n}\n\nwriteMulti = function(x, rc, endian, EWKB) {\n\tunMulti = if (inherits(x, \"MULTILINESTRING\"))\n\t\tst_linestring\n\telse # MULTIPOLYGON, POLYHEDRALSURFACE, TIN:\n\t\tst_polygon\n\twriteBin(as.integer(length(x)), rc, size = 4L, endian = endian)\n\tlapply(lapply(x, unMulti, class(x)[1]), writeData, rc = rc, endian = endian, EWKB = EWKB)\n}\nwriteGC = function(x, rc, endian, EWKB) {\n\twriteBin(as.integer(length(x)), rc, size = 4L, endian = endian)\n\tlapply(x, writeData, rc = rc, endian = endian, EWKB = EWKB)\n}\nwriteMatrix = function(x, rc, endian) {\n\twriteBin(as.integer(nrow(x)), rc, size = 4L, endian = endian)\n\twriteBin(as.double(as.vector(t(x))), rc, size = 8L, endian = endian)\n}\nwriteMatrixList = function(x, rc, endian) {\n\twriteBin(as.integer(length(x)), rc, size = 4L, endian = endian)\n\tlapply(x, function(y) writeMatrix(y, rc, endian))\n}\nwriteMPoints = function(x, rc, endian, EWKB) {\n\twriteBin(as.integer(nrow(x)), rc, size = 4L, endian = endian)\n\tif (nrow(x))\n\t\tapply(x, 1, function(y) writeData(st_point(y, class(x)[1]), rc, endian, EWKB))\n}","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/wkb.R"},{"filename":"sf/R/sp.R","content":"## Method coordinates\n## @name coordinates\n## @exportMethod coordinates\n#if (!isGeneric(\"coordinates\"))\n#    setGeneric(\"coordinates\", function(obj, ...)\n#\t\tstandardGeneric(\"coordinates\"))\n#\n#setMethod(\"coordinates\", \"sfc_POINT\",\n#\tfunction(obj, ...)\n#\t\tdo.call(rbind, obj)\n#)\n#\n#setMethod(\"coordinates\", \"sfc\",\n#\tfunction(obj, ...)\n#\t\tstop(\"coordinates for this object type not implemented\")\n#)\n#\n#setMethod(\"coordinates\", \"sf\",\n#\tfunction(obj, ...)\n#\t\tcoordinates(st_geometry(obj), ...)\n#)\n\n\n#' @rdname st_as_sf\n#' @examples\n#' if (require(sp, quietly = TRUE)) {\n#' x = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))\n#' x1 = 0.1 * x + 0.1\n#' x2 = 0.1 * x + 0.4\n#' x3 = 0.1 * x + 0.7\n#' y = x + 3\n#' y1 = x1 + 3\n#' y3 = x3 + 3\n#' m = matrix(c(3, 0), 5, 2, byrow = TRUE)\n#' z = x + m\n#' z1 = x1 + m\n#' z2 = x2 + m\n#' z3 = x3 + m\n#' p1 = Polygons(list( Polygon(x[5:1,]), Polygon(x2), Polygon(x3),\n#'    Polygon(y[5:1,]), Polygon(y1), Polygon(x1), Polygon(y3)), \"ID1\")\n#' p2 = Polygons(list( Polygon(z[5:1,]), Polygon(z2), Polygon(z3), Polygon(z1)),\n#'   \"ID2\")\n#' r = SpatialPolygons(list(p1,p2))\n#' a = suppressWarnings(st_as_sf(r))\n#' summary(a)\n#' demo(meuse, ask = FALSE, echo = FALSE)\n#' summary(st_as_sf(meuse))\n#' summary(st_as_sf(meuse.grid))\n#' summary(st_as_sf(meuse.area))\n#' summary(st_as_sf(meuse.riv))\n#' summary(st_as_sf(as(meuse.riv, \"SpatialLines\")))\n#' pol.grd = as(meuse.grid, \"SpatialPolygonsDataFrame\")\n#' # summary(st_as_sf(pol.grd))\n#' # summary(st_as_sf(as(pol.grd, \"SpatialLinesDataFrame\")))\n#' }\n#' @export\nst_as_sf.Spatial = function(x, ...) {\n\tif (\"data\" %in% slotNames(x)) {\n                if (!isTRUE(all.equal(row.names(x@data), row.names(x))))\n                    row.names(x@data) <- row.names(x)\n\t\tdf = x@data\n\t} else {\n\t\tdf = data.frame(row.names = row.names(x)) # empty\n        }\n\tif (\"geometry\" %in% names(df))\n\t\twarning(\"column \\\"geometry\\\" will be overwritten by geometry column\")\n\tif (! requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tif (sp::gridded(x) && sp::fullgrid(x))\n\t\tsp::fullgrid(x) = FALSE\n\tdf$geometry = st_as_sfc(sp::geometry(x), ...)\n\tst_as_sf(df)\n}\n\n\n#' Convert foreign geometry object to an sfc object\n#'\n#' Convert foreign geometry object to an sfc object\n#' @param x object to convert\n#' @param ... further arguments\n#' @param precision precision value; see \\link{st_as_binary}\n#' @param forceMulti logical; if \\code{TRUE}, force coercion into \\code{MULTIPOLYGON} or \\code{MULTILINE} objects, else autodetect\n#' @export\nst_as_sfc = function(x, ...) UseMethod(\"st_as_sfc\")\n\nhandle_bbox = function(sfc, sp) {\n\tbb = structure(bb_wrap(as.vector(sp::bbox(sp)[1:2,])), class = \"bbox\")\n\tstructure(sfc, \"bbox\" = bb)\n}\n\n#' @rdname st_as_sfc\n#' @export\nst_as_sfc.SpatialPoints = function(x, ..., precision = 0.0) {\n\tcc = x@coords\n\tdimnames(cc) = NULL\n\tlst = lapply(seq_len(nrow(cc)), function(x) st_point(cc[x,]))\n\thandle_bbox(do.call(st_sfc, append(lst, list(crs = st_crs(x@proj4string), \n\t\tprecision = precision))), x)\n}\n\n#' @rdname st_as_sfc\n#' @export\nst_as_sfc.SpatialPixels = function(x, ..., precision = 0.0) {\n\thandle_bbox(st_as_sfc(as(x, \"SpatialPoints\"), precision = precision), x)\n}\n\n\n#' @rdname st_as_sfc\n#' @export\nst_as_sfc.SpatialMultiPoints = function(x, ..., precision = 0.0) {\n\tlst = lapply(x@coords, st_multipoint)\n\thandle_bbox(do.call(st_sfc, append(lst, list(crs = st_crs(x@proj4string),\n\t\tprecision = precision))), x)\n}\n\n#' @rdname st_as_sfc\n#' @export\nst_as_sfc.SpatialLines = function(x, ..., precision = 0.0, forceMulti = FALSE) {\n\tlst = if (forceMulti || any(sapply(x@lines, function(x) length(x@Lines)) != 1))\n\t\tlapply(x@lines, function(y) {\n                    crd_list <- lapply(y@Lines, function(z) z@coords)\n                    crd_list1 <- lapply(crd_list, function(z) {\n                         if (nrow(z) < 2L) res <- z[0,]\n                         else res <- z\n                         res\n                    })\n                    st_multilinestring(crd_list1)\n                })\n\telse\n\t\tlapply(x@lines, function(y) {\n                    crds = y@Lines[[1]]@coords\n                    if (nrow(crds) < 2L) res = st_linestring()\n                    else res = st_linestring(crds)\n                    res\n                })\n\thandle_bbox(do.call(st_sfc, append(lst, list(crs = st_crs(x@proj4string),\n\t\tprecision = precision))), x)\n}\n\n#' @rdname st_as_sfc\n#' @export\n\nst_as_sfc.SpatialPolygons = function(x, ..., precision = 0.0, forceMulti = FALSE) {\n\tlst = if (forceMulti || any(sapply(x@polygons, function(x) moreThanOneOuterRing(x@Polygons)))) {\n\t\tif (is.null(comment(x)) || comment(x) == \"FALSE\") {\n#\t\t\tif (!requireNamespace(\"rgeos\", quietly = TRUE))\n#\t\t\t\tstop(\"package rgeos required for finding out which hole belongs to which exterior ring\")\n#\t\t\tx = rgeos::createSPComment(x)\n\t\t\t# https://github.com/r-spatial/sf/pull/1869/files/7f1921c9acc1000b92a81b3a0aa7126330d4ef12..cfa303c8fcdd0b9a7ea33eae402c1135bb8e50ba :\n\t\t\t# warning(\"no comment found showing which hole belongs to which exterior ring\")\n\t\t\t# (warning causes revdep problem in pkg amt)\n\t\t\tprocess_pl_comment <- function(pl) {\n\t\t\t\tID <- slot(pl, \"ID\")\n\t\t\t\tcrds <- lapply(slot(pl, \"Polygons\"), function(xx) slot(xx, \"coords\"))\n\t\t\t\tholes <- sapply(slot(pl, \"Polygons\"), slot, \"hole\")\n\t\t\t\traw0 <- st_sfc(lapply(crds, function(x) st_polygon(list(x))))\n\t\t\t\tif (!any(holes)) {\n\t\t\t\t\tval <- st_union(st_make_valid(raw0))\n\t\t\t\t} else {\n\t\t\t\t\twkts <- vector(\"list\", sum(!holes))\n\t\t\t\t\tfor (i in seq_along(wkts)) {\n\t\t\t\t\t\twkts[[i]] <- st_as_text(raw0[!holes][i])\n\t\t\t\t\t}\n\t\t\t\t\tcp0 <- st_contains(raw0[!holes], raw0[holes])\n\t\t\t\t\tareas <- sapply(slot(pl, \"Polygons\"), slot, \"area\")\n\t\t\t\t\thole_assigned <- rep(FALSE, sum(holes))\n\t\t\t\t\tnames(cp0) <- seq_along(cp0)\n                                        cp1 <- cp0[order(areas[!holes])]\n\t\t\t\t\tfor (i in seq_along(cp1)) {\n                                          cp1i <- cp1[[i]]\n\t\t\t\t\t  tgt <- as.integer(names(cp1[i]))\n                                          if (length(cp1i) > 0L) {\n                                            for (j in cp1i) {\n\t\t\t\t\t      wkts[[tgt]] <- paste(sub(\"))\", \"),\", wkts[[tgt]]), sub(\"POLYGON \\\\(\", \"\", st_as_text(raw0[holes][j])))\n\t\t\t\t\t      hole_assigned[j] <- TRUE\n\t\t\t\t\t    }\n                                          }\n\t\t\t\t\t  for (ii in i:length(cp1)) {\n                                            for (j in cp1i) {\n\t\t\t\t\t      cp1[[ii]] <- setdiff(cp1[[ii]], j)\n\t\t\t\t\t    }\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t\tif (any(!hole_assigned))\n\t\t\t\t\t  warning(\"orphaned hole, cannot find containing polygon\")\n\t\t\t\t\traw0 <- st_as_sfc(wkts)\n                                        raw1 <- st_make_valid(raw0)\n                                        if (any(st_is(raw1, \"GEOMETRYCOLLECTION\"))) \n                                          raw1 <- st_collection_extract(raw1, \"POLYGON\")\n\t\t\t\t\tval <- st_union(raw1)\n\t\t\t\t}\n\t\t\t\tif (inherits(val, \"sfc_GEOMETRYCOLLECTION\"))\n\t\t\t\t\tval = st_collection_extract(val, \"POLYGON\")\n\t\t\t\tres <- slot(as(val, \"Spatial\"), \"polygons\")[[1]]\n\t\t\t\tslot(res, \"ID\") <- ID\n\t\t\t\tres\n\t\t\t}\n#\t\t\tprocess_pl_comment <- function(pl) {\n#\t\t\t\tID <- slot(pl, \"ID\")\n#\t\t\t\tcrds <- lapply(slot(pl, \"Polygons\"), function(xx) slot(xx, \"coords\"))\n#\t\t\t\traw <- st_sfc(st_polygon(crds))\n#\t\t\t\tval <- st_make_valid(raw)\n#\t\t\t\tif (inherits(val, \"sfc_GEOMETRYCOLLECTION\"))\n#\t\t\t\t\tval = st_collection_extract(val, \"POLYGON\")\n#\t\t\t\tres <- slot(as(val, \"Spatial\"), \"polygons\")[[1]]\n#\t\t\t\tslot(res, \"ID\") <- ID\n#\t\t\t\tres\n#\t\t\t}\n\t\t\tslot(x, \"polygons\") <- lapply(slot(x, \"polygons\"), process_pl_comment)\n\t\t\tcomment(x) <- \"TRUE\"\n\t\t}\n\t\tlapply(x@polygons, function(y)\n\t\t\tst_multipolygon(Polygons2MULTIPOLYGON(y@Polygons, comment(y))))\n\t} else\n\t\tlapply(x@polygons, function(y) st_polygon(Polygons2POLYGON(y@Polygons)))\n\thandle_bbox(do.call(st_sfc, append(lst, list(crs = st_crs(x@proj4string),\n\t\tprecision = precision))), x)\n}\n\nmoreThanOneOuterRing = function(PolygonsLst) {\n\tholes = sapply(PolygonsLst, function(x) x@hole)\n\tlength(holes) - length(which(holes)) > 1\n}\n\nPolygons2MULTIPOLYGON = function(PolygonsLst, cmt) {\n\tidx = scan(text = cmt, quiet = TRUE)\n\t# idx tells which outer rings (0) enclose which holes (idx == which(idx == 0))\n\touter_rings = which(idx == 0)\n\t# loop over outer_rings:\n\tlapply(outer_rings, function(x) Polygons2POLYGON(PolygonsLst[c(x, which(idx == x))]))\n}\n\nPolygons2POLYGON = function(PolygonsLst) {\n\t# here we have one outer ring, followed by (0+) holes inside this ring\n\tlapply(PolygonsLst, function(x) x@coords)\n}\n\n#' @name as\n#' @rdname coerce-methods\n#' @aliases Spatial sf-method\nsetAs(\"Spatial\", \"sf\", function(from) st_as_sf(from))\n\n#' @name as\n#' @rdname coerce-methods\n#' @aliases coerce Spatial sfc-method\nsetAs(\"Spatial\", \"sfc\", function(from) st_as_sfc(from))\n\n#' @name as\n#' @rdname coerce-methods\n#' @aliases coerce Spatial-method\nsetAs(\"sf\", \"Spatial\", function(from) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tgeom = st_geometry(from)\n\tfrom[[attr(from, \"sf_column\")]] = NULL # remove sf column list\n\tsp::addAttrToGeom(as_Spatial(geom, IDs = row.names(from)),\n\t\tdata.frame(from), match.ID = FALSE)\n})\n\n#' @name as\n#' @rdname coerce-methods\n#' @aliases coerce Spatial-method\nsetAs(\"sfc\", \"Spatial\", function(from) as_Spatial(from))\n\n# create empy class\nsetOldClass(\"XY\")\nsetAs(\"XY\", \"Spatial\", function(from) as(st_sfc(from), \"Spatial\"))\n\n#' Methods to coerce simple features to `Spatial*` and `Spatial*DataFrame` objects\n#'\n#' [as_Spatial()] allows to convert `sf` and `sfc` to `Spatial*DataFrame` and\n#' `Spatial*` for `sp` compatibility. You can also use `as(x, \"Spatial\")` To transform\n#' `sp` objects to `sf` and `sfc` with `as(x, \"sf\")`.\n#' @rdname coerce-methods\n#' @name as_Spatial\n#' @param from object of class `sf`, `sfc_POINT`, `sfc_MULTIPOINT`, `sfc_LINESTRING`,\n#' `sfc_MULTILINESTRING`, `sfc_POLYGON`, or `sfc_MULTIPOLYGON`.\n#' @param cast logical; if `TRUE`, [st_cast()] `from` before converting, so that e.g.\n#' `GEOMETRY` objects with a mix of `POLYGON` and `MULTIPOLYGON` are cast to `MULTIPOLYGON`.\n#' @param IDs character vector with IDs for the `Spatial*` geometries\n#' @details Package \\code{sp} supports three dimensions for `POINT` and `MULTIPOINT` (`SpatialPoint*`).\n#' Other geometries must be two-dimensional (`XY`). Dimensions can be dropped using\n#' [st_zm()] with `what = \"M\"` or `what = \"ZM\"`.\n#'\n#' For converting simple features (i.e., \\code{sf} objects) to their \\code{Spatial} counterpart, use \\code{as(obj, \"Spatial\")}\n#' @return geometry-only object deriving from `Spatial`, of the appropriate class\n#' @export\n#' @examples\n#' nc <- st_read(system.file(\"shape/nc.shp\", package=\"sf\"))\n#' if (require(sp, quietly = TRUE)) {\n#' # convert to SpatialPolygonsDataFrame\n#' spdf <- as_Spatial(nc)\n#' # identical to\n#' spdf <- as(nc, \"Spatial\")\n#' # convert to SpatialPolygons\n#' as(st_geometry(nc), \"Spatial\")\n#' # back to sf\n#' as(spdf, \"sf\")\n#' }\nas_Spatial = function(from, cast = TRUE, IDs = paste0(\"ID\", seq_along(from))) {\n\tif (inherits(from, \"sf\")) {\n\t\tgeom = st_geometry(from)\n\t\tfrom[[attr(from, \"sf_column\")]] = NULL # remove sf column list\n\t\tif (ncol(from))\n\t\t\tsp::addAttrToGeom(as_Spatial(geom, cast = cast, IDs = row.names(from)),\n\t\t\t\t\t\t  data.frame(from), match.ID = FALSE)\n\t\telse {\n\t\t\tif (missing(IDs))\n\t\t\t\tIDs = paste0(\"ID\", seq_along(geom))\n\t\t\tas_Spatial(geom, cast, IDs)\n\t\t}\n\t} else {\n\t\t.as_Spatial(from, cast, IDs)\n\t}\n}\n\n.as_Spatial = function(from, cast = TRUE, IDs = paste0(\"ID\", seq_along(from))) {\n\tif (cast)\n\t\tfrom = st_cast(from)\n\tzm = class(from[[1]])[1]\n\tif (zm %in% c(\"XYM\", \"XYZM\"))\n\t\tstop(\"geometries containing M not supported by sp\\n\",\n\t\t\t 'use `st_zm(..., what = \"M\")`')\n\tif (any(st_is_empty(from)))\n\t\tstop(\"empty geometries are not supported by sp classes: conversion failed\")\n\tStopZ = function(zm) { \n\t\tif (zm == \"XYZ\")\n\t\t\tstop(\"sp supports Z dimension only for POINT and MULTIPOINT.\\n\",\n\t\t\t\t 'use `st_zm(...)` to coerce to XY dimensions')\n\t}\n\tswitch(class(from)[1],\n\t\t\"sfc_POINT\" = sfc2SpatialPoints(from),\n#\t\t\"sfc_POINT\" = sfc2SpatialPoints(from, IDs),\n\t\t\"sfc_MULTIPOINT\" = sfc2SpatialMultiPoints(from),\n\t\t\"sfc_LINESTRING\" = , \"sfc_MULTILINESTRING\" = { StopZ(zm); sfc2SpatialLines(from, IDs) },\n\t\t\"sfc_POLYGON\" = , \"sfc_MULTIPOLYGON\" = { StopZ(zm); sfc2SpatialPolygons(from, IDs) },\n\t\tstop(paste(\"conversion from feature type\", class(from)[1], \"to sp is not supported\"))\n\t)\n}\n\nsfc2SpatialPoints = function(from, IDs) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tsp::SpatialPoints(do.call(rbind, from), proj4string = as(st_crs(from), \"CRS\"))\n}\n\nsfc2SpatialMultiPoints = function(from) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tsp::SpatialMultiPoints(lapply(from, unclass), \n\t\tproj4string = as(st_crs(from), \"CRS\"))\n}\n\nsfc2SpatialLines = function(from, IDs = paste0(\"ID\", seq_along(from))) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tl = if (class(from)[1]  == \"sfc_MULTILINESTRING\")\n\t\tlapply(from, function(x) sp::Lines(lapply(x, function(y) sp::Line(unclass(y))), \"ID\"))\n\telse\n\t\tlapply(from, function(x) sp::Lines(list(sp::Line(unclass(x))), \"ID\"))\n\tfor (i in seq_along(from))\n\t\tl[[i]]@ID = IDs[i]\n\tsp::SpatialLines(l, proj4string = as(st_crs(from), \"CRS\"))\n}\n\nsfc2SpatialPolygons = function(from, IDs = paste0(\"ID\", seq_along(from))) {\n\tif (!requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tl = if (class(from)[1] == \"sfc_MULTIPOLYGON\")\n\t\tlapply(from, function(x)  # for each sfc item, return a Polygons\n\t\t\t\tsp::Polygons(unlist(lapply(x, function(y) # to each sub-polygon,\n\t\t\t\t\tlapply(seq_along(y), function(i) sp::Polygon(y[[i]], i > 1))),\n\t\t\t\t\t\trecursive = FALSE), \"ID\"))\n\telse lapply(from, function(x)\n\t\tsp::Polygons(lapply(seq_along(x), function(i) sp::Polygon(x[[i]], i > 1)), \"ID\"))\n\n\t# set comment: ?Polygons: \"Exterior rings are coded zero, while interior rings are\n\t# coded with the 1-based index of the exterior ring to which they belong.\":\n\tfor (i in seq_along(from)) {\n\t\tl[[i]]@ID = IDs[i]\n\t\tif (class(from)[1] == \"sfc_MULTIPOLYGON\")\n\t\t\tcomm = get_comment(from[[i]])\n\t\telse\n\t\t\tcomm = c(0, rep(1, length(from[[i]])-1))\n\t\tcomment(l[[i]]) = paste(as.character(comm), collapse = \" \")\n\t}\n\tsp::SpatialPolygons(l, proj4string = as(st_crs(from), \"CRS\"))\n}\n\nget_comment = function(mp) { # for MULTIPOLYGON\n\tl = lapply(mp, function(from) c(0, rep(1, length(from) - 1)))\n\toffset = 0\n\tfor (i in seq_along(l)) {\n\t\tl[[i]] = l[[i]] + offset\n\t\toffset = offset + length(l[[i]])\n\t\tl[[i]][1] = 0\n\t}\n\tunlist(l)\n}\n\n#' @name as\n#' @rdname coerce-methods\n#' @aliases coerce crs CRS-method\nsetAs(\"crs\", \"CRS\", function(from) CRS_from_crs(from))\nCRS_from_crs = function(from) {\n\tif (! requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tnm <- \"CRS\"\n\tattr(nm, \"package\") <- \"sp\" # See ?new:\n\tobj <- new(nm, projargs = from$proj4string)\n\tif (!is.na(from$wkt) && CPL_proj_version() >= \"6.0.0\" && CPL_gdal_version() >= \"3.0.0\")\n\t\tcomment(obj) <- from$wkt\n\tobj\n\t# we don't use sp::CRS(SRS_string = from$wkt) as rgdal may not be available,\n\t# which would break, and from$wkt has already been validated by GDAL:\n}","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/sp.R"},{"filename":"sf/R/crs.R","content":"#  alternative, but more limiting from sp/R/CRS-methods.R, https://github.com/edzer/sp/pull/31 @hughjonesd\n#  (no longer used)\n#identicalCRS1 = function(x, y) {\n#  args_x <- strsplit(x, \" +\")[[1]]\n#  args_y <- strsplit(y, \" +\")[[1]]\n#  setequal(args_x, args_y)\n#}\n\n# this function establishes whether two crs objects are semantically identical. This is\n# the case when: (1) they are completely identical (including NA), or (2) GDAL considers\n# them equivalent\n#' @export\nOps.crs <- function(e1, e2) {\n\tif (nargs() == 1)\n\t\tstop(paste(\"unary\", .Generic, \"not defined for \\\"crs\\\" objects\"), call. = FALSE)\n\n\tcmp <- switch(.Generic, \"==\" =, \"!=\" = TRUE, FALSE)\n\tif (!cmp)\n\t\tstop(paste(\"operation\", .Generic, \"not supported for crs objects\"), call. = FALSE)\n\tif (.Generic == \"!=\")\n\t\t!(e1 == e2)\n\telse { # \"==\": check semantic equality\n\t\tif (isTRUE(all.equal(e1, e2))) # includes both are NA_crs_\n\t\t\tTRUE\n\t\telse if (is.na(e1) || is.na(e2)) # only one of them is NA_crs_\n\t\t\tFALSE\n\t\telse\n\t\t\tisTRUE(try(CPL_crs_equivalent(e1, e2), silent = TRUE)) # use GDAL's srs1->IsSame(srs2)\n\t}\n}\n\n#' Retrieve coordinate reference system from object\n#'\n#' Retrieve coordinate reference system from sf or sfc object\n#' @name st_crs\n#' @param x numeric, character, or object of class \\link{sf} or \\link{sfc}\n#' @param ... ignored\n#' @export\n#' @return If \\code{x} is numeric, return \\code{crs} object for EPSG:\\code{x};\n#' if \\code{x} is character, return \\code{crs} object for \\code{x};\n#' if \\code{x} is of class \\code{sf} or \\code{sfc}, return its \\code{crs} object.\n#' @details The *crs functions create, get, set or replace the \\code{crs} attribute\n#' of a simple feature geometry list-column. This attribute is of class \\code{crs},\n#' and is a list consisting of \\code{input} (user input, e.g. \"EPSG:4326\" or \"WGS84\"\n#' or a proj4string), and \\code{wkt}, an automatically generated wkt2 representation of the crs.\n#' If \\code{x} is identical to the wkt2 representation, and the CRS has a name, this name\n#' is used for the \\code{input} field.\n#'\n#' Comparison of two objects of class \\code{crs} uses the GDAL function\n#' \\code{OGRSpatialReference::IsSame}.\n#' @return Object of class \\code{crs}, which is a list with elements \\code{input} (length-1 character)\n#' and \\code{wkt} (length-1 character).\n#' Elements may be \\code{NA} valued; if all elements are \\code{NA} the CRS is missing valued, and coordinates are\n#' assumed to relate to an arbitrary Cartesian coordinate system.\nst_crs = function(x, ...) UseMethod(\"st_crs\")\n\n#' @name st_crs\n#' @export\nst_crs.sf = function(x, ...) st_crs(st_geometry(x), ...)\n\n#' @name st_crs\n#' @export\nst_crs.numeric = function(x, ...) {\n\tif (!is.finite(x))\n\t\tNA_crs_\n\telse\n    \tmake_crs(paste0(\"EPSG:\", x))\n}\n\n\n#' @name st_crs\n#' @export\nst_crs.character = function(x, ...) {\n\tif (is.na(x))\n\t\tNA_crs_\n\telse {\n\t\tcrs = make_crs(x)\n\t\tif (is.na(crs))\n\t\t\tstop(paste(\"invalid crs:\", x))\n\t\t# if we input wkt2, and CRS has a name, use it:\n\t\tif (identical(x, crs$wkt) && !identical(crs$Name, \"unknown\"))\n\t\t\tcrs$input = crs$Name\n\t\tcrs\n\t}\n}\n\nfix_crs = function(x) {\n\tif (all(c(\"epsg\", \"proj4string\") %in% names(x))) {\n\t\tmessage(\"old-style crs object detected; please recreate object with a recent sf::st_crs()\")\n\t\tx = unclass(x)\n\t\tif (!is.na(x$epsg))\n\t\t\tst_crs(x$epsg)\n\t\telse\n\t\t\tst_crs(x$proj4string)\n\t} else\n\t\tx\n}\n\n\n#' @name st_crs\n#' @param parameters logical; \\code{FALSE} by default; if \\code{TRUE} return a list of coordinate reference system parameters, with named elements \\code{SemiMajor}, \\code{InvFlattening}, \\code{units_gdal}, \\code{IsVertical}, \\code{WktPretty}, and \\code{Wkt}\n#' @export\nst_crs.sfc = function(x, ..., parameters = FALSE) {\n\tcrs = fix_crs(attr(x, \"crs\"))\n\tif (parameters) {\n\t\tp = crs_parameters(crs)\n\t\tp$ud_unit = crs_ud_unit(crs)\n\t\tp\n\t} else\n\t\tcrs\n}\n\n#' @name st_crs\n#' @export\nst_crs.bbox = function(x, ...) {\n\tcrs = attr(x, \"crs\")\n\tif (is.null(crs))\n\t\tNA_crs_\n\telse\n\t\tcrs\n}\n\n#' @name st_crs\n#' @export\nst_crs.CRS = function(x, ...) {\n\tif (is.null(comment(x)) || CPL_proj_version() < \"6.0.0\" || \n\t\t\tCPL_gdal_version() < \"3.0.0\")\n\t\tst_crs(x@projargs)\n\telse {\n\t\tret = st_crs(comment(x))\n\t\tname = ret$Name\n\t\tret$input = if (name == \"unknown\")\n\t\t\t\tx@projargs\n\t\t\telse\n\t\t\t\tname\n\t\tret\n\t}\n}\n\n#' @name st_crs\n#' @export\nst_crs.crs = function(x, ...) x\n\n#' @export\nst_crs.default = function(x, ...) NA_crs_\n\n#' Set or replace coordinate reference system from object\n#'\n#' Set or replace retrieve coordinate reference system from object\n#' @name st_crs\n#' @param value one of (i) character: a string accepted by GDAL, (ii) integer, a valid EPSG value (numeric), or (iii) an object of class \\code{crs}.\n#' @details In case a coordinate reference system is replaced, no transformation takes\n#' place and a warning is raised to stress this.\n#'\n#' @export\n`st_crs<-` = function(x, value) UseMethod(\"st_crs<-\")\n\n#' @name st_crs\n#' @examples\n#' sfc = st_sfc(st_point(c(0,0)), st_point(c(1,1)))\n#' sf = st_sf(a = 1:2, geom = sfc)\n#' st_crs(sf) = 4326\n#' st_geometry(sf)\n#' @export\n`st_crs<-.sf` = function(x, value) {\n\tst_crs(x[[ attr(x, \"sf_column\") ]]) = value\n\tx\n}\n\n# return crs object from crs, integer, or character string\nmake_crs = function(x) {\n\n\tif (inherits(x, \"CRS\")) {\n\t\tx = if (is.null(comment(x)) || (CPL_proj_version() < \"6.0.0\" || \n                    CPL_gdal_version() < \"3.0.0\"))\n\n\t\t\t\tx@projargs\n\t\t\telse\n\t\t\t\tcomment(x) # WKT2\n\t}\n\tif (is.numeric(x) && !is.na(x))\n\t\tx = paste0(\"EPSG:\", x)\n\t# return:\n\tif (is.na(x))\n\t\tNA_crs_\n\telse if (inherits(x, \"crs\"))\n\t\tx\n\telse if (is.character(x)) {\n\t\tif (grepl(\"+init=epsg:\", x) &&\n\t\t\t\tcompareVersion(sf_extSoftVersion()[[\"proj.4\"]], \"6.0.0\") >= 0 &&\n\t\t\t\tcompareVersion(sf_extSoftVersion()[[\"proj.4\"]], \"6.3.1\") < 0) { # nocov start FIXME:\n\t\t\tx = strsplit(x, \" \")[[1]]\n\t\t\tif (length(x) > 1)\n\t\t\t\twarning(paste(\"the following proj4string elements are ignored:\",\n\t\t\t\t\tpaste(x[-1], collapse = \" \"), \"; remove the +init=epsg:XXXX to undo this\"))\n\t\t\tx = paste0(\"EPSG:\", as.integer(substr(x[1], 12, 20))) # nocov end\n\t\t}\n\t\tCPL_crs_from_input(x)\n\t} else\n\t\tstop(paste(\"cannot create a crs from an object of class\", class(x)), call. = FALSE)\n}\n\n#' @name st_crs\n#' @examples\n#' sfc = st_sfc(st_point(c(0,0)), st_point(c(1,1)))\n#' st_crs(sfc) = 4326\n#' sfc\n#' @export\n`st_crs<-.sfc` = function(x, value) {\n\n\tif (is.null(attr(x, \"crs\")))\n\t\tstart_crs = NA_crs_\n\telse\n\t\tstart_crs = st_crs(x)\n\n\tend_crs = make_crs(value)\n\n\tif (!is.na(start_crs) && !is.na(end_crs) && start_crs != end_crs)\n\t\twarning(\"st_crs<- : replacing crs does not reproject data; use st_transform for that\", call. = FALSE)\n\n\tif (is.na(end_crs) && !is.na(start_crs) && isTRUE(st_is_longlat(start_crs)) && any(st_is_full(x)))\n\t\tstop(\"To set the crs to NA, first remove the full polygons; see: st_is_full()\")\n\n\tstructure(x, crs = end_crs)\n}\n\n#' @export\n`st_crs<-.bbox` = function(x, value) {\n\tstructure(x, crs = make_crs(value))\n}\n\n\n#' @name st_crs\n#' @examples\n#' sfc = st_sfc(st_point(c(0,0)), st_point(c(1,1)))\n#' sfc %>% st_set_crs(4326) %>% st_transform(3857)\n#' @export\nst_set_crs = function(x, value) {\n\tst_crs(x) = value\n\tx\n}\n\n#' Assert whether simple feature coordinates are longlat degrees\n#'\n#' Assert whether simple feature coordinates are longlat degrees\n#' @param x object of class \\link{sf} or \\link{sfc}, or otherwise an object of a class that has an \\link{st_crs} method returning a \\code{crs} object\n#' @return `TRUE` if `x` has geographic coordinates, `FALSE` if it has projected coordinates, or `NA` if \\code{is.na(st_crs(x))}.\n#' @export\nst_is_longlat = function(x) {\n\tcrs = st_crs(x)\n\tif (is.na(crs))\n\t\tNA\n\telse {\n\t\tret = crs_parameters(crs)$IsGeographic\n\t\tif (ret && inherits(x, c(\"sf\", \"sfc\", \"stars\")) && !is.null(attr(x, \"bbox\"))) {\n\t\t\tbb = st_bbox(x)\n\t\t\t# check for potentially meaningless value range:\n\t\t\teps = sqrt(.Machine$double.eps)\n\t\t\tif (all(!is.na(unclass(bb))) &&\n\t\t\t\t\t(bb[\"xmin\"] < (-180-eps) || bb[\"xmax\"] > (360+eps) || bb[\"ymin\"] < (-90-eps) || bb[\"ymax\"] > (90+eps)))\n\t\t\t\twarning(\"bounding box has potentially an invalid value range for longlat data\")\n\t\t}\n\t\tret\n\t}\n}\n\n# a = \"b\" => a is the proj.4 unit (try: cs2cs -lu); \"b\" is the udunits2 unit\nudunits_from_proj = list(\n#   PROJ.4     UDUNITS\n\t`km` =     as_units(\"km\"),\n\t`m` =      as_units(\"m\"),\n\t`dm` =     as_units(\"dm\"),\n\t`cm` =     as_units(\"cm\"),\n\t`mm` =     as_units(\"mm\"),\n\t`kmi` =    as_units(\"nautical_mile\"),\n\t`in` =     as_units(\"in\"),\n\t`ft` =     as_units(\"ft\"),\n\t`yd` =     as_units(\"yd\"),\n\t`mi` =     as_units(\"mi\"),\n\t`fath` =   as_units(\"fathom\"),\n\t`ch` =     as_units(\"chain\"),\n\t`link` =   as_units(\"link\", check_is_valid = FALSE), # not (yet) existing; set in .onLoad()\n \t`us-in` =  as_units(\"us_in\", check_is_valid = FALSE),\n\t`us-ft` =  as_units(\"US_survey_foot\"),\n\t`us-yd` =  as_units(\"US_survey_yard\"),\n\t`us-ch` =  as_units(\"chain\"),\n\t`us-mi` =  as_units(\"US_survey_mile\"),\n\t`ind-yd` = as_units(\"ind_yd\", check_is_valid = FALSE),\n\t`ind-ft` = as_units(\"ind_ft\", check_is_valid = FALSE),\n\t`ind-ch` = as_units(\"ind_ch\", check_is_valid = FALSE),\n\t`kilometre` =  as_units(\"km\"),\n\t`metre` =  as_units(\"m\"),\n\t`decimetre` =     as_units(\"dm\"),\n\t`centimetre` =     as_units(\"cm\"),\n\t`millimetre` =     as_units(\"mm\"),\n\t`nautical mile` = as_units(\"nautical_mile\"),\n\t`Statute mile` = as_units(\"mi\"),\n \t`US survey inch` =  as_units(\"us_in\", check_is_valid = FALSE),\n\t`US survey foot` =  as_units(\"US_survey_foot\"),\n\t`US survey yard` =  as_units(\"US_survey_yard\"),\n\t`US survey chain` =  as_units(\"chain\"),\n\t`US survey mile` =  as_units(\"US_survey_mile\"),\n\t`Indian yard (1937)` = as_units(\"ind_yd\", check_is_valid = FALSE),\n\t`Indian foot (1937)` = as_units(\"ind_ft\", check_is_valid = FALSE),\n\t`Indian chain` = as_units(\"ind_ch\", check_is_valid = FALSE)\n)\n\ncrs_ud_unit = function(x) {\n\tstopifnot(inherits(x, \"crs\"))\n\tif (is.na(x))\n\t\treturn(NULL)\n\n\tx = crs_parameters(x)\n\tif (!is.null(x$units_gdal)) {\n\t\tu = udunits_from_proj[[x$units_gdal]]\n\t\tif (is.null(u)) {\n\t\t\tu = try(as_units(x$units_gdal), silent = TRUE)\n\t\t\tif (inherits(u, \"try-error\"))\n\t\t\t\tu = NULL\n\t\t}\n\t\tu\n\t} else\n\t\tNULL #2049\n}\n\ncrs_parameters = function(x) {\n\tstopifnot(inherits(x, \"crs\"))\n\tif (is.na(x))\n\t\tlist()\n\telse {\n\t\tret = CPL_crs_parameters(x)\n\t\tunits(ret$SemiMajor) = as_units(\"m\")\n\t\tunits(ret$SemiMinor) = as_units(\"m\")\n\t\tret\n\t}\n}\n\nepsg = function(x) {\n\tif (is.na(x))\n\t\tNA_integer_\n\telse if (grepl(\"^EPSG:\", x[[\"input\"]]))\n\t# else if (startsWith(x[[\"input\"]], \"EPSG:\"))\n\t\tas.integer(gsub(\"^EPSG:(\\\\d+)\\\\b.*$\", \"\\\\1\", x[[\"input\"]]))\n\telse\n\t\tcrs_parameters(x)[[\"epsg\"]]\n}\n\nproj4string = function(x) {\n\tif (is.na(x))\n\t\tNA_character_\n\telse\n\t\tcrs_parameters(x)[[\"proj4string\"]]\n}\n\n\n#' @name st_as_text\n#' @param projjson logical; if TRUE, return projjson form (requires GDAL 3.1 and PROJ 6.2), else return well-known-text form\n#' @param pretty logical; if TRUE, print human-readable well-known-text representation of a coordinate reference system\n#' @export\nst_as_text.crs = function(x, ..., projjson = FALSE, pretty = FALSE) {\n\tif (is.na(x))\n\t\tNA_character_\n\telse if (projjson) {\n\t\tif (compareVersion(sf_extSoftVersion()[\"GDAL\"], \"3.1.0\") == -1 || compareVersion(sf_extSoftVersion()[\"proj.4\"], \"6.2.0\") == -1)\n\t\t\tstop(\"ProjJson requires GDAL >= 3.1.0 and PROJ >= 6.2.0\")\n\t\tcrs_parameters(x)$ProjJson\n\t} else { # wkt:\n\t\tif (pretty)\n\t\t\tcrs_parameters(x)$WktPretty\n\t\telse\n\t\t\tcrs_parameters(x)$Wkt\n\t}\n}\n\n\n#' @name st_crs\n#' @details\n#' \\code{NA_crs_} is the \\code{crs} object with missing values for \\code{input} and \\code{wkt}.\n#' @export\nNA_crs_ = structure(\n\tlist(input = NA_character_,\n\t\twkt = NA_character_),\n\tclass = \"crs\")\n\n#' @name st_crs\n#' @export\n#' @method is.na crs\nis.na.crs = function(x) {\n\tidentical(x, NA_crs_)\n}\n\n#' @name st_crs\n#' @param name element name\n#' @export\n#' @examples\n#' st_crs(\"EPSG:3857\")$input\n#' st_crs(3857)$proj4string\n#' @details the `$` method for `crs` objects retrieves named elements\n#' using the GDAL interface; named elements include\n#' `SemiMajor`, `SemiMinor`, `InvFlattening`, `IsGeographic`,\n#' `units_gdal`, `IsVertical`, `WktPretty`, `Wkt`,\n#' `Name`, `proj4string`, `epsg`, `yx`, \n#' `ud_unit`, and `axes` (this may be subject to changes in future GDAL versions).\n#'\n#' Note that not all valid CRS have a corresponding `proj4string`. \n#'\n#' `ud_unit` returns a valid \\link[units]{units} object or `NULL` if units are missing.\n#' @export\n`$.crs` = function(x, name) {\n\n\tif (!is.null(x[[\"proj4string\"]])) { # old-style object:\n\t\twarning(\"CRS uses proj4string, which is deprecated.\")\n\t\tx = st_crs(x[[\"proj4string\"]]) # FIXME: should this be only for some transition period? Add test?\n\t}\n\tif (name == \"ud_unit\")\n\t\tcrs_ud_unit(x)\n\telse if (is.na(x))\n\t\tNA_character_\n\telse if (is.numeric(name) || name %in% names(x))\n\t\tx[[name]]\n\telse {\n\t\tp = crs_parameters(x)\n\t\tif (name %in% names(p))\n\t\t\tp[[name]]\n\t\telse {\n\t\t\ttryNum = function(x) { n = suppressWarnings(as.numeric(x)); if (is.na(n)) x else n }\n\t\t\tp4s = strsplit(p$proj4string, \" \")[[1]]\n\t\t\tp4s2 = strsplit(p4s, \"=\")\n\t\t\tvals = lapply(p4s2, function(x) if (length(x) == 1) TRUE else tryNum(x[2]))\n\t\t\tnames(vals) = substring(sapply(p4s2, function(x) x[1]), 2)\n\t\t\tvals[[name]]\n\t\t}\n\t}\n}\n\n#' @export\nprint.crs = function(x, ...) {\n  cat(\"Coordinate Reference System:\")\n  if (is.na(x)) {\n    cat(\" NA\\n\")\n  } else {\n    cat(\"\\n\")\n    if (is.na(x$input))\n       cat(\"  No user input\\n\")\n    else\n       cat(\"  User input:\", x$input, \"\\n\")\n\n\t# print wkt:\n    if (!is.na(x$wkt))\n      cat(\"  wkt:\\n\", x$wkt, \"\\n\", sep = \"\")\n  }\n}\n\n#' @name st_crs\n#' @export\n#' @details format.crs returns NA if the crs is missing valued, or else\n#' the name of a crs if it is different from \"unknown\", or\n#' else the user input if it was set, or else its \"proj4string\" representation;\nformat.crs = function(x, ...) {\n\tif (is.na(x))\n\t\tNA_character_\n\telse {\n\t\tp = crs_parameters(x)\n\t\tif (p$Name == \"unknown\") {\n\t\t\tif (x$input == \"unknown\")\n\t\t\t\tx$proj4string\n\t\t\telse\n\t\t\t\tx$input\n\t\t} else\n\t\t\tx$Name\n\t}\n}\n\n\n#' @export\nst_crs.Raster = function(x, ...) {\n\tcrsobj <- raster::crs(x)\n\tst_crs(crsobj) # nocov\n}\n\n#' @export\nst_crs.Spatial = function(x, ...) {\n\tif (! requireNamespace(\"sp\", quietly = TRUE))\n\t\tstop(\"package sp required, please install it first\")\n\tst_crs(x@proj4string) # nocov\n}\n\n#' @name st_crs\n#' @param authority_compliant logical; specify whether axis order should be\n#' handled compliant to the authority; if omitted, the current value is printed.\n#' @details\n#' \\code{st_axis_order} can be used to get and set the axis order: \\code{TRUE}\n#' indicates axes order according to the authority\n#' (e.g. EPSG:4326 defining coordinates to be latitude,longitude pairs), \\code{FALSE}\n#' indicates the usual GIS (display) order (longitude,latitude). This can be useful\n#' when data are read, or have to be written, with coordinates in authority compliant order.\n#' The return value is the current state of this (\\code{FALSE}, by default).\n#' @return \\code{st_axis_order} returns the (logical) current value if called without\n#' argument, or (invisibly) the previous value if it is being set.\n#' @export\n#' @examples\n#' pt = st_sfc(st_point(c(0, 60)), crs = 4326)\n#' # st_axis_order() only has effect in GDAL >= 2.5.0:\n#' st_axis_order() # query default: FALSE means interpret pt as (longitude latitude)\n#' st_transform(pt, 3857)[[1]]\n#' old_value = FALSE\n#' if (compareVersion(sf_extSoftVersion()[\"GDAL\"], \"2.5.0\") >= 0)\n#'    (old_value = st_axis_order(TRUE))\n#' # now interpret pt as (latitude longitude), as EPSG:4326 prescribes:\n#' st_axis_order() # query current value\n#' st_transform(pt, 3857)[[1]]\n#' st_axis_order(old_value) # set back to old value\nst_axis_order = function(authority_compliant = logical(0)) {\n\tret = CPL_axis_order_authority_compliant(authority_compliant)\n\tif (length(authority_compliant))\n\t\tinvisible(ret)\n\telse\n\t\tret\n}","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/crs.R"},{"filename":"sf/R/cast_sfc.R","content":"#' Cast geometry to another type: either simplify, or cast explicitly\n#'\n#' Cast geometry to another type: either simplify, or cast explicitly\n#'\n#' @param x object of class \\code{sfg}, \\code{sfc} or \\code{sf}\n#' @param to character; target type, if missing, simplification is tried; when \\code{x} is of type \\code{sfg} (i.e., a single geometry) then \\code{to} needs to be specified.\n#' @return object of class \\code{to} if successful, or unmodified object if unsuccessful. If information gets lost while type casting, a warning is raised.\n#' @examples\n#' s = st_multipoint(rbind(c(1,0)))\n#' st_cast(s, \"POINT\")\n#' @export\nst_cast <- function(x, to, ...) UseMethod(\"st_cast\")\n\n# see this figure:\n# https://cloud.githubusercontent.com/assets/520851/21387553/5f1edcaa-c778-11e6-92d0-2d735e4c8e40.png\n# columns start counting at 0:\n\nwhich_sfc_col = function(cls) {\n\tstopifnot(!missing(cls))\n\tswitch(cls,\n\t\tPOINT = 0,\n\t\tLINESTRING = 1,\n\t\tMULTIPOINT = 1,\n\t\tMULTILINESTRING = 2,\n\t\tPOLYGON = 2,\n\t\tMULTIPOLYGON = 3,\n\t\tMULTICURVE = 3,\n\t\tGEOMETRYCOLLECTION = 4,\n\t\tCOMPOUNDCURVE = 4,\n\t\tMULTISURFACE = 4,\n\t\tCURVEPOLYGON = 4,\n\t\tGEOMETRY = 5,\n\t\tstop(paste(\"st_cast for\", cls, \"not supported\"))\n\t)\n}\n\n# does this geometry type need closed polygons?\nneed_close = function(cls) {\n\tswitch(cls,\n\t\tPOLYGON = TRUE,\n\t\tMULTIPOLYGON = TRUE,\n\t\tFALSE\n\t)\n}\n\n# add y's attributes to x, return x\nadd_attributes = function(x, y) {\n\tattributes(x) = attributes(y)\n\tx\n}\n\nclose_polygon_or_multipolygon = function(x, to) {\n\tto_col = which_sfc_col(to)\n\tclose_mat = function(m) {\n\t\tif (any(m[1,] != m[nrow(m),]))\n\t\t\tm = rbind(m, m[1,])\n\t\tif (nrow(m) < 4)\n\t\t\tstop(\"polygons require at least 4 points\")\n\t\tunclass(m)\n\t}\n\tadd_attributes(\n\t\tif (to_col == 2)\n\t\t\tlapply(x, function(y) add_attributes(lapply(y, close_mat), y))\n\t\telse if (to_col == 3)\n\t\t\tlapply(x, function(y) add_attributes(lapply(y, function(z) lapply(z, close_mat)), y))\n\t\telse\n\t\t\tstop(\"invalid to_col value\")\n\t, x)\n}\n\n# change the class of sfc x, and all its sfg list elements\n# (vertical cast)\nreclass = function(x, to, must_close) {\n\tl = if (length(x)) {\n\t\tfull_cls = c(class(x[[1]])[1], to, \"sfg\")\n\t\tif (must_close)\n\t\t\tx = close_polygon_or_multipolygon(x, to)\n\t\tlapply(x, function(g) structure(g, class = full_cls))\n\t} else\n\t\tlist()\n\tattributes(l) = attributes(x)\n\tstructure(l, class = c(paste0(\"sfc_\", to), \"sfc\"))\n}\n\n# how long is each geometry in the sfc?\nget_lengths = function(x) {\n\tswitch(class(x)[1],\n\t\tsfc_POINT = rep(1, length(x)),\n\t\tsfc_MULTIPOINT = vapply(x, nrow, 0L),\n\t\tsfc_LINESTRING = vapply(x, nrow, 0L),\n\t\tlengths(x) # list\n\t)\n}\n\n#' Coerce geometry to MULTI* geometry\n#'\n#' Mixes of POINTS and MULTIPOINTS, LINESTRING and MULTILINESTRING,\n#' POLYGON and MULTIPOLYGON are returned as MULTIPOINTS, MULTILINESTRING and MULTIPOLYGONS respectively\n#' @param x list of geometries or simple features\n#' @details Geometries that are already MULTI* are left unchanged.\n#' Features that can't be cast to a single  MULTI* geometry are return as a\n#' GEOMETRYCOLLECTION\nst_cast_sfc_default = function(x) {\n\n\tif (length(x) == 0)\n\t\treturn(x)\n\n\tif (!identical(unique(vapply(x, function(w) class(w)[3L], \"\")), \"sfg\"))\n\t\tstop(\"list item(s) not of class sfg\") # sanity check\n\n\ta <- attributes(x)\n\tids = NULL\n\tcls = unique(vapply(x, function(x) class(x)[2L], \"\"))\n\tif (length(cls) > 1) {\n\t\tif (all(cls %in% c(\"POINT\", \"MULTIPOINT\"))) {\n\t\t\tx <- lapply(x, function(x) if (inherits(x, \"POINT\")) POINT2MULTIPOINT(x) else x)\n\t\t\tclass(x) <- c(\"sfc_MULTIPOINT\", \"sfc\")\n\t\t} else if (all(cls %in% c(\"LINESTRING\", \"MULTILINESTRING\"))) {\n\t\t\tx <- lapply(x, function(x) if (inherits(x, \"LINESTRING\")) LINESTRING2MULTILINESTRING(x) else x)\n\t\t\tclass(x) <- c(\"sfc_MULTILINESTRING\", \"sfc\")\n\t\t} else if (all(cls %in% c(\"POLYGON\", \"MULTIPOLYGON\"))) {\n\t\t\tx <- lapply(x, function(x) if (inherits(x, \"POLYGON\")) POLYGON2MULTIPOLYGON(x) else x)\n\t\t\tclass(x) <- c(\"sfc_MULTIPOLYGON\", \"sfc\")\n\t\t}\n\t} else if (cls == \"GEOMETRYCOLLECTION\" && all(lengths(x))) { # https://github.com/r-spatial/sf/issues/1767\n\t\tids = get_lengths(x)\n\t\tx <- do.call(st_sfc, unlist(x, recursive = FALSE))\n\t}\n\tattributes(x) <- a\n\tstructure(st_sfc(x), ids = ids)\n}\n\ncopy_sfc_attributes_from = function(x, ret) {\n\tstructure(ret, precision = attr(x, \"precision\"),\n\t\tbbox = attr(x, \"bbox\"), crs = attr(x, \"crs\"), n_empty = attr(x, \"n_empty\"))\n}\n\nempty_sfg <- function(to) {\n\tswitch(to,\n\t\t   GEOMETRYCOLLECTION = st_geometrycollection(),\n\t\t   MULTIPOLYGON = st_multipolygon(),\n\t\t   POLYGON = st_polygon(),\n\t\t   MULTILINESTRING = st_multilinestring(),\n\t\t   LINESTRING = st_linestring(),\n\t\t   MULTIPOINT = st_multipoint(),\n\t\t   POINT = st_point()\n\t   )\n}\n\nis_exotic = function(x) {\n\tstopifnot(length(x) > 0)\n\tif (inherits(x, c(\"sfc_MULTICURVE\", \"sfc_COMPOUNDCURVE\", \"sfc_CURVEPOLYGON\", \"sfc_MULTISURFACE\"))) # for which GEOS has no st_is_empty()\n\t\tTRUE\n\telse if (inherits(x, \"sfc_GEOMETRY\")) {\n\t\tcls = sapply(x, class)\n\t\tany(cls[2,] %in% c(\"MULTICURVE\", \"COMPOUNDCURVE\", \"CURVEPOLYGON\", \"MULTISURFACE\"))\n\t} else\n\t\tFALSE\n}\n\n#' @name st_cast\n#' @param ids integer vector, denoting how geometries should be grouped (default: no grouping)\n#' @param group_or_split logical; if TRUE, group or split geometries; if FALSE, carry out a 1-1 per-geometry conversion.\n#' @param ... ignored\n#' @export\n#' @return In case \\code{to} is missing, \\code{st_cast.sfc} will coerce combinations of \"POINT\" and \"MULTIPOINT\", \"LINESTRING\" and \"MULTILINESTRING\", \"POLYGON\" and \"MULTIPOLYGON\" into their \"MULTI...\" form, or in case all geometries are \"GEOMETRYCOLLECTION\" will return a list of all the contents of the \"GEOMETRYCOLLECTION\" objects, or else do nothing. In case \\code{to} is specified, if \\code{to} is \"GEOMETRY\", geometries are not converted, else, \\code{st_cast} will try to coerce all elements into \\code{to}; \\code{ids} may be specified to group e.g. \"POINT\" objects into a \"MULTIPOINT\", if not specified no grouping takes place. If e.g. a \"sfc_MULTIPOINT\" is cast to a \"sfc_POINT\", the objects are split, so no information gets lost, unless \\code{group_or_split} is \\code{FALSE}.\n#' @details When converting a GEOMETRYCOLLECTION to COMPOUNDCURVE, MULTISURFACE or CURVEPOLYGON, the user is responsible for the validity of the resulting object: no checks are being carried out by the software.\n#' \n#' When converting mixed, GEOMETRY sets, it may help to first convert to the MULTI-type, see examples\n#' @examples\n#' # https://github.com/r-spatial/sf/issues/1930:\n#' pt1 <- st_point(c(0,1))\n#' pt23 <- st_multipoint(matrix(c(1,2,3,4), ncol = 2, byrow = TRUE))\n#' d <- st_sf(geom = st_sfc(pt1, pt23))\n#' st_cast(d, \"POINT\") # will not convert the entire MULTIPOINT, and warns\n#' st_cast(d, \"MULTIPOINT\") %>% st_cast(\"POINT\")\nst_cast.sfc = function(x, to, ..., ids = seq_along(x), group_or_split = TRUE) {\n\tif (missing(to) || length(x) == 0)\n\t\treturn(st_cast_sfc_default(x))\n\n\te = rep(FALSE, length(x))\n\tif (!is_exotic(x)) { # for which GEOS has no st_is_empty()\n\t\te = st_is_empty(x)\n\t\tif (all(e)) {\n\t\t\tx[e] = empty_sfg(to)\n\t\t\treturn(x) # RETURNS\n\t\t}\n\t}\n\tif (any(e))\n\t\tx = x[!e]\n\tfrom_cls = substr(class(x)[1], 5, 100)\n\tfrom_col = which_sfc_col(from_cls)\n\tto_col = which_sfc_col(to)\n\tret = if (from_cls == to)\n\t\tx # returns x: do nothing\n\telse if (to == \"GEOMETRY\") # we can always do that:\n\t\tstructure(x, class = c(\"sfc_GEOMETRY\", \"sfc\"))\n\telse if (from_cls == \"GEOMETRY\" || !group_or_split)\n\t\tst_sfc(lapply(x, st_cast, to = to), crs = st_crs(x), precision = st_precision(x))\n\telse if (from_col == to_col) # \"vertical\" conversion: only reclass, possibly close polygons\n\t\treclass(x, to, need_close(to))\n\telse if (abs(from_col - to_col) > 1) {\n\t\tif (to == \"POINT\")\n\t\t\tst_cast(st_cast(x, \"MULTIPOINT\"), \"POINT\")\n\t\telse if (to == \"MULTIPOINT\") {\n\t\t\tret = lapply(x, function(y) structure(as.matrix(y), class = c(class(y)[1], to, \"sfg\")))\n\t\t\tret = copy_sfc_attributes_from(x, ret)\n\t\t\treclass(ret, to, FALSE)\n\t\t} else\n\t\t\t#st_cast(st_cast(x, \"MULTILINESTRING\"), to)\n\t\t\tstop(\"use smaller steps for st_cast; first cast to MULTILINESTRING or POLYGON?\")\n\t} else if (from_col < to_col) { # \"horizontal\", to the right: group\n\t\tret = if (from_col == 0)\n\t\t\t\tlapply(unname(split(x, ids)), function(y) structure(do.call(rbind, y), \n\t\t\t\t\tclass = class(x[[1]])))\n\t\t\telse\n\t\t\t\tlapply(unname(split(x, ids)), function(y) structure(y, class = class(x[[1]])))\n\t\tret = copy_sfc_attributes_from(x, ret)\n\t\treclass(ret, to, need_close(to))\n\t} else if (from_col == 3 && to == \"MULTILINESTRING\") {\n\t\tif (from_cls == \"MULTICURVE\") {\n\t\t\tret = lapply(x, st_cast, to = \"MULTILINESTRING\")\n\t\t} else {\n\t\t\tret = lapply(x, unlist, recursive = FALSE) # unlist one level deeper; one MULTIPOLYGON -> one MULTILINESTRING\n\t\t\tif (length(ret))\n\t\t\t\tclass(ret[[1]]) = class(x[[1]]) # got dropped\n\t\t}\n\t\tret = copy_sfc_attributes_from(x, ret)\n\t\tstructure(reclass(ret, to, FALSE))\n\t} else { # \"horizontal\", to the left: split\n\t\tret = if (from_col == 1) # LINESTRING or MULTIPOINT to POINT\n\t\t\t\tunlist(lapply(x, function(m) lapply(seq_len(nrow(m)), function(i) m[i,])), recursive = FALSE)\n\t\t\telse {\n\t\t\t\tif (to_col == 0 && from_cls == \"POLYGON\") # POLYGON -> POINT\n\t\t\t\t\tlapply(x, function(y) do.call(rbind, y))\n\t\t\t\telse\n\t\t\t\t\tunlist(x, recursive = FALSE)\n\t\t\t}\n\t\tret = lapply(ret, function(y) structure(y, class = class(x[[1]]))) # will be reset by reclass()\n\t\tret = copy_sfc_attributes_from(x, ret)\n\t\t# EJP: FIXME:\n\t\tstructure(reclass(ret, to, need_close(to)), ids = get_lengths(x))\n\t}\n\tif (any(e)) {\n\t\tcrs = st_crs(x)\n\t\tx = vector(\"list\", length = length(e))\n\t\tx[e] = list(empty_sfg(to))\n\t\tx[!e] = ret\n\t\tst_set_crs(do.call(st_sfc, x), crs)\n\t} else\n\t\tret\n}\n\n#' @name st_cast\n#' @param warn logical; if \\code{TRUE}, warn if attributes are assigned to sub-geometries\n#' @param do_split logical; if \\code{TRUE}, allow splitting of geometries in sub-geometries\n#' @export\n#' @details the \\code{st_cast} method for \\code{sf} objects can only split geometries, e.g. cast \\code{MULTIPOINT} into multiple \\code{POINT} features.  In case of splitting, attributes are repeated and a warning is issued when non-constant attributes are assigned to sub-geometries. To merge feature geometries and attribute values, use \\link[sf:aggregate.sf]{aggregate} or \\link[sf:tidyverse]{summarise}.\nst_cast.sf = function(x, to, ..., warn = TRUE, do_split = TRUE) {\n\tgeom = st_cast(st_geometry(x), to, group_or_split = do_split)\n\tagr = st_agr(x)\n\tall_const = all_constant(x)\n\tsf_column = attr(x, \"sf_column\") # keep name\n\tst_geometry(x) = NULL\n\t# class(x) = setdiff(class(x), \"sf\")\n\tids = attr(geom, \"ids\")          # e.g. 3 2 4\n\tif (!is.null(ids)) { # split:\n\t\tif (warn && ! all_const)\n\t\t\twarning(\"repeating attributes for all sub-geometries for which they may not be constant\")\n\t\treps = rep(seq_len(length(ids)), ids) # 1 1 1 2 2 3 3 3 3 etc\n\t\tagr[agr == \"identity\"] = \"constant\" # since we splitted\n\t\tx = x[reps,, drop = FALSE]\n\t\tstopifnot(nrow(x) == length(geom))\n\t}\n\tattr(geom, \"ids\") = NULL # remove\n\tx[[sf_column]] = geom\n\tst_geometry(x) = sf_column\n\tst_agr(x) = agr\n\tx\n}\n\n#' @name st_cast\n#' @export\nst_cast.sfc_CIRCULARSTRING <- function(x, to, ...) {\n\tif (isTRUE(st_is_longlat(x)))\n\t\tmessage_longlat(\"st_cast\")\n\tstopifnot(to == \"LINESTRING\")\n\tst_sfc(CPL_circularstring_to_linestring(st_sfc(x)), crs = st_crs(x)) # should add attributes?\n}\n\n#' test equality between the geometry type and a class or set of classes\n#'\n#' test equality between the geometry type and a class or set of classes\n#' @param x object of class \\code{sf}, \\code{sfc} or \\code{sfg}\n#' @param type character; class, or set of classes, to test against\n#' @examples\n#' st_is(st_point(0:1), \"POINT\")\n#' sfc = st_sfc(st_point(0:1), st_linestring(matrix(1:6,,2)))\n#' st_is(sfc, \"POINT\")\n#' st_is(sfc, \"POLYGON\")\n#' st_is(sfc, \"LINESTRING\")\n#' st_is(st_sf(a = 1:2, sfc), \"LINESTRING\")\n#' st_is(sfc, c(\"POINT\", \"LINESTRING\"))\n#' @export\nst_is = function(x, type) UseMethod(\"st_is\")\n\n#' @export\nst_is.sf = function(x, type)\n\tst_is(st_geometry(x), type)\n\n#' @export\nst_is.sfc = function(x, type)\n\tvapply(x, inherits, type, FUN.VALUE = logical(1))\n\n#' @export\nst_is.sfg = function(x, type)\n\tinherits(x, type)","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/cast_sfc.R"},{"filename":"sf/R/RcppExports.R","content":"# Generated by using Rcpp::compileAttributes() -> do not edit by hand\n# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393\n\nCPL_get_bbox <- function(sf, depth = 0L) {\n    .Call(`_sf_CPL_get_bbox`, sf, depth)\n}\n\nCPL_gdal_init <- function() {\n    invisible(.Call(`_sf_CPL_gdal_init`))\n}\n\nCPL_gdal_cleanup_all <- function() {\n    invisible(.Call(`_sf_CPL_gdal_cleanup_all`))\n}\n\nCPL_gdal_version <- function(what = \"RELEASE_NAME\") {\n    .Call(`_sf_CPL_gdal_version`, what)\n}\n\nCPL_crs_parameters <- function(crs) {\n    .Call(`_sf_CPL_crs_parameters`, crs)\n}\n\nCPL_crs_equivalent <- function(crs1, crs2) {\n    .Call(`_sf_CPL_crs_equivalent`, crs1, crs2)\n}\n\nCPL_crs_from_input <- function(input) {\n    .Call(`_sf_CPL_crs_from_input`, input)\n}\n\nCPL_roundtrip <- function(sfc) {\n    .Call(`_sf_CPL_roundtrip`, sfc)\n}\n\nCPL_circularstring_to_linestring <- function(sfc) {\n    .Call(`_sf_CPL_circularstring_to_linestring`, sfc)\n}\n\nCPL_multisurface_to_multipolygon <- function(sfc) {\n    .Call(`_sf_CPL_multisurface_to_multipolygon`, sfc)\n}\n\nCPL_compoundcurve_to_linear <- function(sfc) {\n    .Call(`_sf_CPL_compoundcurve_to_linear`, sfc)\n}\n\nCPL_curve_to_linestring <- function(sfc) {\n    .Call(`_sf_CPL_curve_to_linestring`, sfc)\n}\n\nCPL_can_transform <- function(src, dst) {\n    .Call(`_sf_CPL_can_transform`, src, dst)\n}\n\nCPL_transform <- function(sfc, crs, AOI, pipeline, reverse = FALSE, desired_accuracy = -1.0, allow_ballpark = TRUE) {\n    .Call(`_sf_CPL_transform`, sfc, crs, AOI, pipeline, reverse, desired_accuracy, allow_ballpark)\n}\n\nCPL_transform_bounds <- function(bb, crs_dst, densify_pts = 21L) {\n    .Call(`_sf_CPL_transform_bounds`, bb, crs_dst, densify_pts)\n}\n\nCPL_wrap_dateline <- function(sfc, opt, quiet = TRUE) {\n    .Call(`_sf_CPL_wrap_dateline`, sfc, opt, quiet)\n}\n\nCPL_get_gdal_drivers <- function(dummy) {\n    .Call(`_sf_CPL_get_gdal_drivers`, dummy)\n}\n\nCPL_sfc_from_wkt <- function(wkt) {\n    .Call(`_sf_CPL_sfc_from_wkt`, wkt)\n}\n\nCPL_gdal_with_geos <- function() {\n    .Call(`_sf_CPL_gdal_with_geos`)\n}\n\nCPL_axis_order_authority_compliant <- function(authority_compliant) {\n    .Call(`_sf_CPL_axis_order_authority_compliant`, authority_compliant)\n}\n\nCPL_area <- function(sfc) {\n    .Call(`_sf_CPL_area`, sfc)\n}\n\nCPL_gdal_dimension <- function(sfc, NA_if_empty = TRUE) {\n    .Call(`_sf_CPL_gdal_dimension`, sfc, NA_if_empty)\n}\n\nCPL_length <- function(sfc) {\n    .Call(`_sf_CPL_length`, sfc)\n}\n\nCPL_gdal_segmentize <- function(sfc, dfMaxLength = 0.0) {\n    .Call(`_sf_CPL_gdal_segmentize`, sfc, dfMaxLength)\n}\n\nCPL_gdal_linestring_sample <- function(sfc, distLst) {\n    .Call(`_sf_CPL_gdal_linestring_sample`, sfc, distLst)\n}\n\nCPL_get_layers <- function(datasource, options, do_count = FALSE) {\n    .Call(`_sf_CPL_get_layers`, datasource, options, do_count)\n}\n\nCPL_read_ogr <- function(datasource, layer, query, options, quiet, toTypeUser, fid_column_name, drivers, wkt_filter, promote_to_multi = TRUE, int64_as_string = FALSE, dsn_exists = TRUE, dsn_isdb = FALSE, width = 80L) {\n    .Call(`_sf_CPL_read_ogr`, datasource, layer, query, options, quiet, toTypeUser, fid_column_name, drivers, wkt_filter, promote_to_multi, int64_as_string, dsn_exists, dsn_isdb, width)\n}\n\nCPL_read_gdal_stream <- function(stream_xptr, datasource, layer, query, options, quiet, drivers, wkt_filter, dsn_exists, dsn_isdb, fid_column, width) {\n    .Call(`_sf_CPL_read_gdal_stream`, stream_xptr, datasource, layer, query, options, quiet, drivers, wkt_filter, dsn_exists, dsn_isdb, fid_column, width)\n}\n\nCPL_gdalinfo <- function(obj, options, oo, co) {\n    .Call(`_sf_CPL_gdalinfo`, obj, options, oo, co)\n}\n\nCPL_ogrinfo <- function(obj, options, oo, co, read_only = FALSE) {\n    .Call(`_sf_CPL_ogrinfo`, obj, options, oo, co, read_only)\n}\n\nCPL_gdaladdo <- function(obj, method, overviews, bands, oo, co, clean = FALSE, read_only = FALSE) {\n    .Call(`_sf_CPL_gdaladdo`, obj, method, overviews, bands, oo, co, clean, read_only)\n}\n\nCPL_gdalwarp <- function(src, dst, options, oo, doo, co, quiet = TRUE, overwrite = FALSE) {\n    .Call(`_sf_CPL_gdalwarp`, src, dst, options, oo, doo, co, quiet, overwrite)\n}\n\nCPL_gdalrasterize <- function(src, dst, options, oo, doo, co, overwrite = FALSE, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalrasterize`, src, dst, options, oo, doo, co, overwrite, quiet)\n}\n\nCPL_gdaltranslate <- function(src, dst, options, oo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdaltranslate`, src, dst, options, oo, co, quiet)\n}\n\nCPL_gdalfootprint <- function(src, dst, options, oo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalfootprint`, src, dst, options, oo, co, quiet)\n}\n\nCPL_gdalvectortranslate <- function(src, dst, options, oo, doo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalvectortranslate`, src, dst, options, oo, doo, co, quiet)\n}\n\nCPL_gdalbuildvrt <- function(src, dst, options, oo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalbuildvrt`, src, dst, options, oo, co, quiet)\n}\n\nCPL_gdaldemprocessing <- function(src, dst, options, processing, colorfilename, oo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdaldemprocessing`, src, dst, options, processing, colorfilename, oo, co, quiet)\n}\n\nCPL_gdalnearblack <- function(src, dst, options, oo, doo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalnearblack`, src, dst, options, oo, doo, co, quiet)\n}\n\nCPL_gdalgrid <- function(src, dst, options, oo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalgrid`, src, dst, options, oo, co, quiet)\n}\n\nCPL_gdalmdiminfo <- function(obj, options, oo, co) {\n    .Call(`_sf_CPL_gdalmdiminfo`, obj, options, oo, co)\n}\n\nCPL_gdalmdimtranslate <- function(src, dst, options, oo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdalmdimtranslate`, src, dst, options, oo, co, quiet)\n}\n\nCPL_gdal_warper <- function(infile, outfile, options, oo, doo, co, quiet = TRUE) {\n    .Call(`_sf_CPL_gdal_warper`, infile, outfile, options, oo, doo, co, quiet)\n}\n\nCPL_write_ogr <- function(obj, dsn, layer, driver, dco, lco, geom, dim, fids, ConfigOptions, quiet, append, delete_dsn = FALSE, delete_layer = FALSE, write_geometries = TRUE, width = 80L) {\n    .Call(`_sf_CPL_write_ogr`, obj, dsn, layer, driver, dco, lco, geom, dim, fids, ConfigOptions, quiet, append, delete_dsn, delete_layer, write_geometries, width)\n}\n\nCPL_delete_ogr <- function(dsn, layer, driver, quiet = TRUE) {\n    .Call(`_sf_CPL_delete_ogr`, dsn, layer, driver, quiet)\n}\n\nCPL_geos_binop <- function(sfc0, sfc1, op, par = 0.0, pattern = \"\", prepared = FALSE) {\n    .Call(`_sf_CPL_geos_binop`, sfc0, sfc1, op, par, pattern, prepared)\n}\n\nCPL_geos_is_valid_reason <- function(sfc) {\n    .Call(`_sf_CPL_geos_is_valid_reason`, sfc)\n}\n\nCPL_geos_make_valid <- function(sfc, method, keep_collapsed) {\n    .Call(`_sf_CPL_geos_make_valid`, sfc, method, keep_collapsed)\n}\n\nCPL_geos_is_valid <- function(sfc, NA_on_exception = TRUE) {\n    .Call(`_sf_CPL_geos_is_valid`, sfc, NA_on_exception)\n}\n\nCPL_geos_is_simple <- function(sfc) {\n    .Call(`_sf_CPL_geos_is_simple`, sfc)\n}\n\nCPL_geos_is_empty <- function(sfc) {\n    .Call(`_sf_CPL_geos_is_empty`, sfc)\n}\n\nCPL_geos_normalize <- function(sfc) {\n    .Call(`_sf_CPL_geos_normalize`, sfc)\n}\n\nCPL_geos_union <- function(sfc, by_feature = FALSE, is_coverage = FALSE) {\n    .Call(`_sf_CPL_geos_union`, sfc, by_feature, is_coverage)\n}\n\nCPL_geos_snap <- function(sfc0, sfc1, tolerance) {\n    .Call(`_sf_CPL_geos_snap`, sfc0, sfc1, tolerance)\n}\n\nCPL_geos_op <- function(op, sfc, bufferDist, nQuadSegs, dTolerance, preserveTopology, bOnlyEdges = 1L, endCapStyle = 0L, joinStyle = 0L, mitreLimit = 1L, singleside = 0L) {\n    .Call(`_sf_CPL_geos_op`, op, sfc, bufferDist, nQuadSegs, dTolerance, preserveTopology, bOnlyEdges, endCapStyle, joinStyle, mitreLimit, singleside)\n}\n\nCPL_geos_voronoi <- function(sfc, env, dTolerance = 0.0, bOnlyEdges = 1L) {\n    .Call(`_sf_CPL_geos_voronoi`, sfc, env, dTolerance, bOnlyEdges)\n}\n\nCPL_geos_op2 <- function(op, sfcx, sfcy) {\n    .Call(`_sf_CPL_geos_op2`, op, sfcx, sfcy)\n}\n\nCPL_geos_version <- function(runtime = FALSE, capi = FALSE) {\n    .Call(`_sf_CPL_geos_version`, runtime, capi)\n}\n\nCPL_geos_dist <- function(sfc0, sfc1, which, par) {\n    .Call(`_sf_CPL_geos_dist`, sfc0, sfc1, which, par)\n}\n\nCPL_geos_nearest_feature <- function(sfc0, sfc1) {\n    .Call(`_sf_CPL_geos_nearest_feature`, sfc0, sfc1)\n}\n\nCPL_geos_nearest_points <- function(sfc0, sfc1, pairwise) {\n    .Call(`_sf_CPL_geos_nearest_points`, sfc0, sfc1, pairwise)\n}\n\nCPL_transpose_sparse_incidence <- function(m, n) {\n    .Call(`_sf_CPL_transpose_sparse_incidence`, m, n)\n}\n\nCPL_nary_difference <- function(sfc) {\n    .Call(`_sf_CPL_nary_difference`, sfc)\n}\n\nCPL_nary_intersection <- function(sfc) {\n    .Call(`_sf_CPL_nary_intersection`, sfc)\n}\n\nCPL_line_project <- function(lines, points, normalized) {\n    .Call(`_sf_CPL_line_project`, lines, points, normalized)\n}\n\nCPL_line_interpolate <- function(lines, dists, normalized) {\n    .Call(`_sf_CPL_line_interpolate`, lines, dists, normalized)\n}\n\nCPL_hex_to_raw <- function(cx) {\n    .Call(`_sf_CPL_hex_to_raw`, cx)\n}\n\nCPL_raw_to_hex <- function(raw) {\n    .Call(`_sf_CPL_raw_to_hex`, raw)\n}\n\nCPL_read_mdim <- function(file, array_names, oo, offset, count, step, proxy = FALSE, debug = FALSE) {\n    .Call(`_sf_CPL_read_mdim`, file, array_names, oo, offset, count, step, proxy, debug)\n}\n\nCPL_write_mdim <- function(name, driver, dimensions, variables, wkt, xy, RootGroupOptions, CreationOptions, as_float = TRUE) {\n    .Call(`_sf_CPL_write_mdim`, name, driver, dimensions, variables, wkt, xy, RootGroupOptions, CreationOptions, as_float)\n}\n\nopp_sfc <- function(geom, value, mult, crs) {\n    .Call(`_sf_opp_sfc`, geom, value, mult, crs)\n}\n\nnormalize_sfc <- function(geom, min, range, crs) {\n    .Call(`_sf_normalize_sfc`, geom, min, range, crs)\n}\n\nCPL_polygonize <- function(raster, mask_name, raster_driver, vector_driver, vector_dsn, options, iPixValField, contour_options, use_contours = FALSE, use_integer = TRUE) {\n    .Call(`_sf_CPL_polygonize`, raster, mask_name, raster_driver, vector_driver, vector_dsn, options, iPixValField, contour_options, use_contours, use_integer)\n}\n\nCPL_rasterize <- function(raster, raster_driver, sfc, values, options, NA_value) {\n    .Call(`_sf_CPL_rasterize`, raster, raster_driver, sfc, values, options, NA_value)\n}\n\nCPL_proj_h <- function(b = FALSE) {\n    .Call(`_sf_CPL_proj_h`, b)\n}\n\nCPL_get_pipelines <- function(crs, authority, AOI, Use, grid_availability, accuracy = -1.0, strict_containment = FALSE, axis_order_auth_compl = FALSE) {\n    .Call(`_sf_CPL_get_pipelines`, crs, authority, AOI, Use, grid_availability, accuracy, strict_containment, axis_order_auth_compl)\n}\n\nCPL_get_data_dir <- function(from_proj = FALSE) {\n    .Call(`_sf_CPL_get_data_dir`, from_proj)\n}\n\nCPL_is_network_enabled <- function(b = FALSE) {\n    .Call(`_sf_CPL_is_network_enabled`, b)\n}\n\nCPL_enable_network <- function(url, enable = TRUE) {\n    .Call(`_sf_CPL_enable_network`, url, enable)\n}\n\nCPL_set_data_dir <- function(data_dir, with_proj) {\n    .Call(`_sf_CPL_set_data_dir`, data_dir, with_proj)\n}\n\nCPL_use_proj4_init_rules <- function(v) {\n    .Call(`_sf_CPL_use_proj4_init_rules`, v)\n}\n\nCPL_proj_version <- function(b = FALSE) {\n    .Call(`_sf_CPL_proj_version`, b)\n}\n\nCPL_proj_is_valid <- function(proj4string) {\n    .Call(`_sf_CPL_proj_is_valid`, proj4string)\n}\n\nCPL_have_datum_files <- function(foo) {\n    .Call(`_sf_CPL_have_datum_files`, foo)\n}\n\nCPL_proj_direct <- function(from_to, pts, keep, warn = TRUE, authority_compliant = FALSE) {\n    .Call(`_sf_CPL_proj_direct`, from_to, pts, keep, warn, authority_compliant)\n}\n\nCPL_proj_info <- function(type) {\n    .Call(`_sf_CPL_proj_info`, type)\n}\n\nCPL_xy2sfc <- function(cc, dim, to_points, which, cc_has_NAs) {\n    .Call(`_sf_CPL_xy2sfc`, cc, dim, to_points, which, cc_has_NAs)\n}\n\nsfc_is_null <- function(sfc) {\n    .Call(`_sf_sfc_is_null`, sfc)\n}\n\nsfc_unique_sfg_dims_and_types <- function(sfc) {\n    .Call(`_sf_sfc_unique_sfg_dims_and_types`, sfc)\n}\n\nsfc_is_empty <- function(sfc) {\n    .Call(`_sf_sfc_is_empty`, sfc)\n}\n\nsfc_is_full <- function(sfc) {\n    .Call(`_sf_sfc_is_full`, sfc)\n}\n\npoints_cpp <- function(pts, gdim = \"XY\") {\n    .Call(`_sf_points_cpp`, pts, gdim)\n}\n\nCPL_signed_area <- function(pts) {\n    .Call(`_sf_CPL_signed_area`, pts)\n}\n\nCPL_get_metadata <- function(obj, domain_item, options) {\n    .Call(`_sf_CPL_get_metadata`, obj, domain_item, options)\n}\n\nCPL_get_crs <- function(obj, options) {\n    .Call(`_sf_CPL_get_crs`, obj, options)\n}\n\nCPL_inv_geotransform <- function(gt_r) {\n    .Call(`_sf_CPL_inv_geotransform`, gt_r)\n}\n\nCPL_read_gdal <- function(fname, options, driver, read_data, NA_value, RasterIO_parameters, max_cells) {\n    .Call(`_sf_CPL_read_gdal`, fname, options, driver, read_data, NA_value, RasterIO_parameters, max_cells)\n}\n\nCPL_write_gdal <- function(x, fname, driver, options, Type, dims, from, gt, p4s, na_val, scale_offset, create = TRUE, only_create = FALSE) {\n    invisible(.Call(`_sf_CPL_write_gdal`, x, fname, driver, options, Type, dims, from, gt, p4s, na_val, scale_offset, create, only_create))\n}\n\nCPL_extract <- function(input, xy, interpolate) {\n    .Call(`_sf_CPL_extract`, input, xy, interpolate)\n}\n\nCPL_create <- function(file, nxy, value, wkt, xlim, ylim) {\n    invisible(.Call(`_sf_CPL_create`, file, nxy, value, wkt, xlim, ylim))\n}\n\nCPL_read_wkb <- function(wkb_list, EWKB = FALSE, spatialite = FALSE) {\n    .Call(`_sf_CPL_read_wkb`, wkb_list, EWKB, spatialite)\n}\n\nCPL_write_wkb <- function(sfc, EWKB = FALSE) {\n    .Call(`_sf_CPL_write_wkb`, sfc, EWKB)\n}\n\nCPL_get_z_range <- function(sf, depth) {\n    .Call(`_sf_CPL_get_z_range`, sf, depth)\n}\n\nCPL_get_m_range <- function(sf, depth) {\n    .Call(`_sf_CPL_get_m_range`, sf, depth)\n}\n\n# Register entry points for exported C++ functions\nmethods::setLoadAction(function(ns) {\n    .Call(`_sf_RcppExport_registerCCallable`)\n})","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/RcppExports.R"},{"filename":"sf/R/s2.R","content":"# see https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view?pli=1#slide=id.i0\n# and the r-spatial/s2 package:\n# https://github.com/r-spatial/s2\n\n#' @export\n#' @param ... passed on\n#' @param use_s2 logical; if \\code{TRUE}, use the s2 spherical geometry package\n#' for geographical coordinate operations\n#' @name s2\n#' @return \\code{sf_use_s2} returns the value of this variable before (re)setting it,\n#' invisibly if \\code{use_s2} is not missing.\nsf_use_s2 = function(use_s2) {\n\tret_val = getOption(\"sf_use_s2\", default = TRUE)\n\tif (! missing(use_s2)) {\n\t\tstopifnot(is.logical(use_s2), length(use_s2)==1, !is.na(use_s2))\n\t\tif (ret_val != use_s2)\n\t\t\tmessage(paste0(\"Spherical geometry (s2) switched \", ifelse(use_s2, \"on\", \"off\")))\n\t\toptions(sf_use_s2 = use_s2)\n\t\tinvisible(ret_val)\n\t} else\n\t\tret_val\n}\n\n#' @name st_as_sfc\n#' @export\n#' @param crs coordinate reference system to be assigned; object of class \\code{crs}\n#' @param endian integer; 0 or 1: defaults to the endian of the native machine\nst_as_sfc.s2_geography = function(x, ..., crs = st_crs(4326),\n\t\tendian = match(.Platform$endian, c(\"big\", \"little\")) - 1L) {\n\tst_cast(st_as_sfc(s2::s2_as_binary(x, endian = endian), ..., crs = crs))\n}\n\n#' @name st_as_sf\n#' @param crs coordinate reference system to be assigned; object of class \\code{crs}\n#' @export\nst_as_sf.s2_geography = function(x, ..., crs = st_crs(4326)) {\n\tst_sf(geometry = st_as_sfc(x, ..., crs = crs))\n}\n\n# dynamically exported in tidyverse.R\nas_s2_geography.sfg <- function(x, ..., oriented = getOption(\"s2_oriented\", FALSE)) {\n\tb = structure(list(st_as_binary(x)), class = \"WKB\")\n\ts2::as_s2_geography(b, ..., oriented = oriented)\n}\n\n# dynamically exported in tidyverse.R\nas_s2_geography.sfc <- function(x, ..., oriented = getOption(\"s2_oriented\", FALSE) || isTRUE(attr(x, \"oriented\"))) {\n\tst_as_s2.sfc(x, ..., oriented = oriented)\n}\n\n# dynamically exported in tidyverse.R\nas_s2_geography.sf <- function(x, ...) {\n\tst_as_s2.sf(x, ...)\n}\n\n#' functions for spherical geometry, using s2 package\n#'\n#' functions for spherical geometry, using the s2 package based on the google s2geometry.io library\n#' @name s2\n#' @param x object of class \\code{sf}, \\code{sfc} or \\code{sfg}\n#' @export\n#' @details \\code{st_as_s2} converts an \\code{sf} POLYGON object into a form readable by \\code{s2}.\n#' @examples\n#' m = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))\n#' m1 = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,0), c(-1,-1))\n#' m0 = m[5:1,]\n#' mp = st_multipolygon(list(\n#'\tlist(m, 0.8 * m0, 0.01 * m1 + 0.9),\n#'\tlist(0.7* m, 0.6*m0),\n#'\tlist(0.5 * m0),\n#'\tlist(m+2),\n#'\tlist(m+4,(.9*m0)+4)\n#'\t))\n#' sf = st_sfc(mp, mp, crs = 'EPSG:4326')\n#' s2 = st_as_s2(sf)\nst_as_s2 = function(x, ...) UseMethod(\"st_as_s2\")\n\n#' @name s2\n#' @export\nst_as_s2.sf = function(x, ...) st_as_s2(st_geometry(x), ...)\n\n#' @name s2\n#' @param oriented logical; if \\code{FALSE}, polygons that\n#' cover more than half of the globe are inverted; if \\code{TRUE}, no reversal\n#' takes place and it is assumed that the inside of the polygon is to the\n#' left of the polygon's path.\n#' @param rebuild logical; call \\link[s2]{s2_rebuild} on the geometry (think of this as a \\code{st_make_valid} on the sphere)\n#' @export\nst_as_s2.sfc = function(x, ..., oriented = getOption(\"s2_oriented\", FALSE) || isTRUE(attr(x, \"oriented\")), \n\t\t\t\t\t\trebuild = FALSE) {\n\tif (!is.na(st_crs(x)) && !st_is_longlat(x))\n\t\tx = st_transform(x, ifelse(st_axis_order(), \"OGC:CRS84\", \"EPSG:4326\"))\n\tif (length(x) && nchar(class(x[[1]])[1]) > 2) { # Z, M, ZM:\n\t\tmessage(\"st_as_s2(): dropping Z and/or M coordinate\")\n\t\tx = st_zm(x)\n\t}\n\tif (rebuild)\n\t\ts2::s2_rebuild(s2::as_s2_geography(st_as_binary(x), ..., oriented = oriented, check = FALSE))\n\telse\n\t\ts2::as_s2_geography(st_as_binary(x), ..., oriented = oriented)\n}","normpath":"C:/Users/runneradmin/AppData/Local/Temp/Rtmp4Yqj55/renv-package-new-77c7dc411be/sf/R/s2.R"}],"prof_output":"C:\\Users\\RUNNER~1\\AppData\\Local\\Temp\\Rtmp2Xi09H\\file1f0446804147.prof","highlight":{"output":["^output\\$"],"gc":["^<GC>$"],"stacktrace":["^\\.\\.stacktraceo(n|ff)\\.\\.$"]},"split":"h"}},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</section>
<section id="results-when-applying-1" class="level3" data-number="1.9">
<h3 data-number="1.9" class="anchored" data-anchor-id="results-when-applying-1"><span class="header-section-number">1.9</span> results when applying</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>s2_squares <span class="ot">&lt;-</span> <span class="fu">get_all_s2_squares_on_sphere</span>(<span class="at">alpha =</span> <span class="dv">10</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>s2_centroids <span class="ot">&lt;-</span> s2_squares <span class="sc">|&gt;</span> </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_centroid</span>()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> s2_squares) <span class="sc">+</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>() <span class="sc">+</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> s2_centroids, <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="fl">0.5</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/list_files_results_s2_squares-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#--------------------------------------------------</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>s2_squares_moll <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  s2_squares,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">crs =</span> <span class="st">"+proj=moll"</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>s2_centroids_moll <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  s2_centroids,</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">crs =</span> <span class="st">"+proj=moll"</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> s2_squares_moll) <span class="sc">+</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> s2_centroids_moll, <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">cex =</span> <span class="fl">0.5</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/list_files_results_s2_squares-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Retour au sommet</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copié");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copié");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/a-lambda\.github\.io\/dive-R-city\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Powered by <a href="https://quarto.org">Quarto</a>.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>